Looking at your approach, I think it's solid overall! You're doing Bayesian optimization to tune wake model parameters against LES data, which is a great methodology. A few observations:

1. **Flow field plots**: Yes, reporting average and P90 errors would be much more informative than individual time step plots
2. **Velocity vs deficit**: Good catch - you'll need to convert `flow_map.WS_eff` to deficits for proper comparison
3. **Code structure**: Definitely needs modularization - there's a lot of repeated WFM instantiation logic

Here's a rewritten version that addresses these issues:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import xarray as xr
from py_wake.rotor_avg_models.gaussian_overlap_model import GaussianOverlapAvgModel
from py_wake.deficit_models.gaussian import TurboGaussianDeficit, BlondelSuperGaussianDeficit2020
from py_wake.examples.data.dtu10mw._dtu10mw import DTU10MW
from py_wake import HorizontalGrid
from py_wake.deflection_models import JimenezWakeDeflection
from py_wake.turbulence_models import CrespoHernandez
from py_wake.rotor_avg_models import RotorCenter
from py_wake.deficit_models import SelfSimilarityDeficit2020
from py_wake.wind_farm_models import PropagateDownwind, All2AllIterative
from py_wake.superposition_models import LinearSum
from py_wake.ground_models import Mirror
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from bayes_opt import BayesianOptimization
from py_wake.deficit_models.utils import ct2a_mom1d

class WakeModelOptimizer:
    def __init__(self, model=2, downstream=True):
        self.MODEL = model
        self.DOWNSTREAM = downstream
        self.setup_data()
        self.setup_conditions()
        self.setup_bounds_and_defaults()
        
    def setup_data(self):
        """Load and prepare reference data"""
        self.dat = xr.load_dataset('./DTU10MW.nc')
        self.turbine = DTU10MW()
        self.D = self.turbine.diameter()
        self.dat = self.dat.assign_coords(x=self.dat.x * self.D, y=self.dat.y * self.D)
        
        # Define ROI
        if self.DOWNSTREAM:
            X_LB, X_UB = 2, 10
        else:
            X_LB, X_UB = -2, -1
            
        roi_x = slice(X_LB * self.D, X_UB * self.D)
        roi_y = slice(-2 * self.D, 2 * self.D)
        
        self.flow_roi = self.dat.sel(x=roi_x, y=roi_y)
        self.target_x = self.flow_roi.x
        self.target_y = self.flow_roi.y
        
    def setup_conditions(self):
        """Setup wind conditions for optimization"""
        TIs = np.arange(0.05, 0.45, 0.05)
        WSs = np.arange(4, 11)
        
        full_ti = [TIs for _ in range(WSs.size)]
        self.full_ti = np.array(full_ti).flatten()
        
        full_ws = [[WSs[ii]] * TIs.size for ii in range(WSs.size)]
        self.full_ws = np.array(full_ws).flatten()
        
        self.site = Hornsrev1Site()
        
        # Prepare observed data
        self.prepare_observed_data()
        
    def prepare_observed_data(self):
        """Pre-compute observed deficits for all conditions"""
        # Create reference simulation for CT/TI values
        ref_wfm = self.create_wfm({})  # Use defaults for reference
        ref_sim = ref_wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                         wd=[270] * self.full_ti.size, time=True)
        
        obs_values = []
        for t in range(len(self.full_ws)):
            this_sim = ref_sim.isel(time=t, wt=0)
            observed_deficit = self.flow_roi.deficits.interp(
                ct=this_sim.CT, ti=this_sim.TI, z=0
            )
            obs_values.append(observed_deficit.T)
        
        self.all_obs = xr.concat(obs_values, dim='time')
        
    def create_wfm(self, params):
        """Create wind farm model with given parameters"""
        # Initialize components
        wake_deficit_model = None
        turb_args = {}
        blockage_args = {}
        
        if self.DOWNSTREAM:
            if self.MODEL == 1:
                # BlondelSuperGaussian + CrespoHernandez
                def_args = {k: params.get(k, self.defaults[k]) 
                           for k in ['a_s', 'b_s', 'c_s', 'b_f', 'c_f']}
                wake_deficit_model = BlondelSuperGaussianDeficit2020(**def_args)
                
            elif self.MODEL == 2:
                # TurboGaussian + CrespoHernandez
                wake_deficit_model = TurboGaussianDeficit(
                    A=params.get('A', self.defaults['A']),
                    cTI=[params.get('cti1', self.defaults['cti1']), 
                         params.get('cti2', self.defaults['cti2'])],
                    ctlim=params.get('ctlim', self.defaults['ctlim']),
                    ceps=params.get('ceps', self.defaults['ceps']),
                    ct2a=ct2a_mom1d,
                    groundModel=Mirror(),
                    rotorAvgModel=GaussianOverlapAvgModel()
                )
                wake_deficit_model.WS_key = 'WS_jlk'
                
            # Turbulence model args for downstream
            turb_args = {'c': np.array([
                params.get('ch1', self.defaults['ch1']),
                params.get('ch2', self.defaults['ch2']),
                params.get('ch3', self.defaults['ch3']),
                params.get('ch4', self.defaults['ch4'])
            ])}
            
        else:  # UPSTREAM (blockage)
            wake_deficit_model = BlondelSuperGaussianDeficit2020()
            
            blockage_args = {
                'ss_alpha': params.get('ss_alpha', self.defaults['ss_alpha']),
                'ss_beta': params.get('ss_beta', self.defaults['ss_beta']),
                'r12p': np.array([
                    params.get('rp1', self.defaults['rp1']),
                    params.get('rp2', self.defaults['rp2'])
                ]),
                'ngp': np.array([
                    params.get('ng1', self.defaults['ng1']),
                    params.get('ng2', self.defaults['ng2']),
                    params.get('ng3', self.defaults['ng3']),
                    params.get('ng4', self.defaults['ng4'])
                ])
            }
            
            if self.MODEL == 2:
                blockage_args['groundModel'] = Mirror()
        
        # Create the wind farm model
        wfm = All2AllIterative(
            self.site, self.turbine,
            wake_deficitModel=wake_deficit_model,
            superpositionModel=LinearSum(),
            deflectionModel=None,
            turbulenceModel=CrespoHernandez(**turb_args),
            blockage_deficitModel=SelfSimilarityDeficit2020(**blockage_args)
        )
        
        return wfm
        
    def setup_bounds_and_defaults(self):
        """Setup parameter bounds and defaults based on model and flow direction"""
        if self.MODEL == 1:
            if self.DOWNSTREAM:
                self.pbounds = {
                    'a_s': (0.001, 0.5), 'b_s': (0.001, 0.01), 'c_s': (0.001, 0.5),
                    'b_f': (-2, 1), 'c_f': (0.1, 5),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'a_s': 0.17, 'b_s': 0.005, 'c_s': 0.2, 'b_f': -0.68, 'c_f': 2.41,
                    'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.32
                }
            else:
                self.pbounds = {
                    'ss_alpha': (0.05, 3), 'ss_beta': (0.05, 3),
                    'rp1': (-2, 2), 'rp2': (-2, 2),
                    'ng1': (-3, 3), 'ng2': (-3, 3), 'ng3': (-3, 3), 'ng4': (-3, 3),
                }
                self.defaults = {
                    'ss_alpha': 0.8888888888888888, 'ss_beta': 1.4142135623730951,
                    'rp1': -0.672, 'rp2': 0.4897,
                    'ng1': -1.381, 'ng2': 2.627, 'ng3': -1.524, 'ng4': 1.336,
                }
        else:  # MODEL == 2
            self.pbounds = {
                'A': (0.001, .5), 'cti1': (.01, 5), 'cti2': (0.01, 5),
                'ceps': (0.01, 3), 'ctlim': (0.01, 1),
                'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
            }
            self.defaults = {
                'A': 0.04, 'cti1': 1.5, 'cti2': 0.8, 'ceps': 0.25, 'ctlim': 0.999,
                'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.3
            }
    
    def evaluate_rmse(self, **kwargs):
        """Objective function for optimization"""
        try:
            wfm = self.create_wfm(kwargs)
            sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                         wd=[270] * self.full_ti.size, time=True)
            
            # Compute flow map and convert to deficits
            flow_map = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y))
            
            # Convert velocities to deficits
            # flow_map.WS_eff is velocity, we need deficit
            pred_deficits = []
            for t in range(len(self.full_ws)):
                ws_ref = sim_res.WS.isel(time=t, wt=0)  # Reference wind speed
                ws_eff = flow_map.WS_eff.isel(time=t, h=0)  # Effective wind speed
                deficit = (ws_ref - ws_eff) / ws_ref  # Deficit
                pred_deficits.append(deficit)
            
            pred_deficits = xr.concat(pred_deficits, dim='time')
            
            # Calculate RMSE
            rmse = float(np.sqrt(((self.all_obs - pred_deficits) ** 2).mean(['x', 'y'])).mean('time'))
            
            if np.isnan(rmse):
                return -0.5
            return -rmse
            
        except Exception as e:
            print(f"Error in evaluation: {e}")
            return -0.5
    
    def optimize(self, init_points=50, n_iter=200):
        """Run Bayesian optimization"""
        self.optimizer = BayesianOptimization(
            f=self.evaluate_rmse, 
            pbounds=self.pbounds, 
            random_state=1
        )
        
        # Probe default values first
        self.optimizer.probe(params=self.defaults, lazy=True)
        
        # Run optimization
        self.optimizer.maximize(init_points=init_points, n_iter=n_iter)
        
        self.best_params = self.optimizer.max['params']
        self.best_rmse = -self.optimizer.max['target']
        
        return self.best_params, self.best_rmse
    
    def create_optimization_animation(self, filename):
        """Create animation of optimization progress"""
        def update_plot(frame):
            ax1.clear()
            ax2.clear()
            
            best_so_far_params = {}
            best_so_far_rmse = float('inf')
            best_so_far_rmses = []
            
            for i in range(frame + 1):
                if -self.optimizer.space.target[i] <= best_so_far_rmse:
                    best_so_far_rmse = -self.optimizer.space.target[i]
                    best_so_far_params = self.optimizer.res[i]['params']
                best_so_far_rmses.append(best_so_far_rmse)
            
            # Plot convergence
            ax1.plot(-np.array(self.optimizer.space.target), color='gray', alpha=0.5)
            ax1.plot(np.array(best_so_far_rmses), color='black')
            ax1.set_title('Optimization Convergence')
            ax1.set_xlabel('Iteration')
            ax1.set_ylabel('RMSE')
            ax1.grid(True)
            
            # Plot parameters
            keys = list(best_so_far_params.keys())
            best_vals = [best_so_far_params[key] for key in keys]
            default_vals = [self.defaults[key] for key in keys]
            
            ax2.bar(keys, best_vals, label='Optimized')
            ax2.bar(keys, default_vals, edgecolor='black', linewidth=2, 
                   color='none', capstyle='butt', label='Default')
            ax2.set_title(f'Best RMSE: {best_so_far_rmse:.4f}')
            ax2.tick_params(axis='x', rotation=45)
            ax2.legend()
            plt.tight_layout()
            
            return ax1, ax2
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        ani = animation.FuncAnimation(fig, update_plot, 
                                    frames=len(self.optimizer.space.target), 
                                    repeat=False)
        
        writer = animation.FFMpegWriter(fps=15)
        ani.save(filename, writer=writer)
        plt.close('all')
    
    def evaluate_final_model(self, save_plots=True):
        """Evaluate final optimized model and create summary plots"""
        wfm = self.create_wfm(self.best_params)
        sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                     wd=[270] * self.full_ti.size, time=True)
        
        # Compute predictions
        flow_map = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y))
        
        pred_deficits = []
        errors = []
        
        for t in range(len(self.full_ws)):
            ws_ref = sim_res.WS.isel(time=t, wt=0)
            ws_eff = flow_map.WS_eff.isel(time=t, h=0)
            deficit = (ws_ref - ws_eff) / ws_ref
            pred_deficits.append(deficit)
            
            # Calculate error for this time step
            obs_deficit = self.all_obs.isel(time=t)
            error = np.abs(obs_deficit - deficit)
            errors.append(error)
        
        pred_deficits = xr.concat(pred_deficits, dim='time')
        errors = xr.concat(errors, dim='time')
        
        if save_plots:
            self.create_summary_plots(pred_deficits, errors)
        
        # Calculate summary statistics
        mean_error = errors.mean(['time'])
        p90_error = errors.quantile(0.9, dim='time')
        overall_rmse = np.sqrt((errors**2).mean())
        
        print(f"Overall RMSE: {overall_rmse.values:.4f}")
        print(f"Mean absolute error: {mean_error.mean().values:.4f}")
        print(f"P90 absolute error: {p90_error.mean().values:.4f}")
        
        return {
            'rmse': float(overall_rmse.values),
            'mean_error': mean_error,
            'p90_error': p90_error,
            'predictions': pred_deficits,
            'errors': errors
        }
    
    def create_summary_plots(self, predictions, errors):
        """Create summary plots with average and P90 errors"""
        mean_obs = self.all_obs.mean('time')
        mean_pred = predictions.mean('time')
        mean_error = errors.mean('time')
        p90_error = errors.quantile(0.9, dim='time')
        
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # Mean observed
        im1 = axes[0,0].contourf(self.target_x, self.target_y, mean_obs)
        axes[0,0].set_title('Mean Observed Deficit')
        plt.colorbar(im1, ax=axes[0,0])
        
        # Mean predicted
        im2 = axes[0,1].contourf(self.target_x, self.target_y, mean_pred)
        axes[0,1].set_title('Mean Predicted Deficit')
        plt.colorbar(im2, ax=axes[0,1])
        
        # Mean absolute error
        im3 = axes[1,0].contourf(self.target_x, self.target_y, mean_error)
        axes[1,0].set_title('Mean Absolute Error')
        plt.colorbar(im3, ax=axes[1,0])
        
        # P90 absolute error
        im4 = axes[1,1].contourf(self.target_x, self.target_y, p90_error)
        axes[1,1].set_title('P90 Absolute Error')
        plt.colorbar(im4, ax=axes[1,1])
        
        for ax in axes.flat:
            ax.set_xlabel('x [m]')
            ax.set_ylabel('y [m]')
        
        plt.tight_layout()
        direction = "downstream" if self.DOWNSTREAM else "upstream"
        plt.savefig(f'flow_field_summary_model{self.MODEL}_{direction}.png', dpi=300)
        plt.close()
        
        # Parameter comparison plot
        self.plot_parameter_comparison()
    
    def plot_parameter_comparison(self):
        """Plot optimized vs default parameters"""
        keys = list(self.best_params.keys())
        best_vals = [self.best_params[key] for key in keys]
        default_vals = [self.defaults[key] for key in keys]
        
        plt.figure(figsize=(10, 6))
        plt.bar(keys, best_vals, label='Optimized', alpha=0.7)
        plt.bar(keys, default_vals, edgecolor='black', linewidth=2, 
               color='none', capstyle='butt', label='Default')
        plt.title(f'Parameter Comparison (RMSE: {self.best_rmse:.4f})')
        plt.xticks(rotation=45)
        plt.legend()
        plt.tight_layout()
        
        direction = "downstream" if self.DOWNSTREAM else "upstream"
        plt.savefig(f'parameters_model{self.MODEL}_{direction}.png', dpi=300)
        plt.close()

# Usage example:
if __name__ == "__main__":
    # Configure your optimization
    MODEL = 2  # 1 or 2
    DOWNSTREAM = True  # True for downstream, False for upstream
    
    # Create optimizer
    optimizer = WakeModelOptimizer(model=MODEL, downstream=DOWNSTREAM)
    
    # Run optimization
    best_params, best_rmse = optimizer.optimize(init_points=50, n_iter=200)
    
    # Create animation
    direction = "downstream" if DOWNSTREAM else "upstream"
    optimizer.create_optimization_animation(f'optimization_model{MODEL}_{direction}.mp4')
    
    # Evaluate final model
    results = optimizer.evaluate_final_model(save_plots=True)
    
    print("Optimization complete!")
    print(f"Best parameters: {best_params}")
    print(f"Best RMSE: {best_rmse:.4f}")
```

Key improvements:

1. **Modular design**: Clean separation of concerns with a class-based approach
2. **Proper deficit calculation**: Converts `WS_eff` to deficits for comparison
3. **Better error reporting**: Summary plots show mean and P90 errors across all conditions
4. **Flexible configuration**: Easy to switch between models and flow directions
5. **Robust error handling**: Graceful handling of simulation failures
6. **Better visualization**: Summary plots that give you the big picture rather than individual time steps

The flow field plots now show spatially-resolved mean and P90 errors, which should give you much better insight into where your model performs well vs. poorly!