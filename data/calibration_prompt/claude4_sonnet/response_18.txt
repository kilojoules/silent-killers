Looking at your code, I think your approach is solid! You're doing Bayesian optimization to calibrate wake/blockage models against reference data, which is a great methodology. You're right about needing to change the flow field analysis - currently you're comparing velocity deficits (reference) to effective velocities (model), and reporting average/p90 errors would be much more informative.

Here's a modularized rewrite that addresses your concerns:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import xarray as xr
from py_wake.rotor_avg_models.gaussian_overlap_model import GaussianOverlapAvgModel
from py_wake.deficit_models.gaussian import TurboGaussianDeficit, BlondelSuperGaussianDeficit2020
from py_wake.examples.data.dtu10mw._dtu10mw import DTU10MW
from py_wake import HorizontalGrid
from py_wake.deflection_models import JimenezWakeDeflection
from py_wake.turbulence_models import CrespoHernandez
from py_wake.rotor_avg_models import RotorCenter
from py_wake.deficit_models import SelfSimilarityDeficit2020
from py_wake.wind_farm_models import PropagateDownwind, All2AllIterative
from py_wake.superposition_models import LinearSum
from py_wake.ground_models import Mirror
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from bayes_opt import BayesianOptimization
from py_wake.deficit_models.utils import ct2a_mom1d

class WakeModelCalibrator:
    def __init__(self, model_type=1, upstream=False):
        """
        Initialize the calibrator
        
        Parameters:
        -----------
        model_type : int (1 or 2)
            1: BlondelSuperGaussian (downstream) or SelfSimilarity (upstream)
            2: TurboGaussian (downstream) or SelfSimilarity+Mirror (upstream)
        upstream : bool
            True for blockage (upstream), False for wake (downstream)
        """
        self.model_type = model_type
        self.upstream = upstream
        self.turbine = DTU10MW()
        self.D = self.turbine.diameter()
        self.site = Hornsrev1Site()
        
        # Load and process reference data
        self._load_reference_data()
        
        # Setup optimization parameters
        self._setup_optimization_bounds()
        
    def _load_reference_data(self):
        """Load and process reference dataset"""
        self.dat = xr.load_dataset('./DTU10MW.nc')
        self.dat = self.dat.assign_coords(x=self.dat.x * self.D, y=self.dat.y * self.D)
        
        # Define region of interest
        if self.upstream:
            X_LB, X_UB = -2, -1
        else:
            X_LB, X_UB = 2, 10
            
        self.roi_x = slice(X_LB * self.D, X_UB * self.D)
        self.roi_y = slice(-2 * self.D, 2 * self.D)
        self.flow_roi = self.dat.sel(x=self.roi_x, y=self.roi_y)
        self.target_x = self.flow_roi.x
        self.target_y = self.flow_roi.y
        
        # Setup test conditions
        TIs = np.arange(0.05, 0.45, 0.05)
        WSs = np.arange(4, 11)
        full_ti = [TIs for _ in range(WSs.size)]
        self.full_ti = np.array(full_ti).flatten()
        full_ws = [[WSs[ii]] * TIs.size for ii in range(WSs.size)]
        self.full_ws = np.array(full_ws).flatten()
        
        # Precompute reference deficits for all conditions
        self._precompute_reference_deficits()
        
    def _precompute_reference_deficits(self):
        """Precompute reference deficits for all test conditions"""
        # Run baseline simulation to get CT/TI values
        baseline_wfm = self._create_wfm({})  # Empty params uses defaults
        sim_res = baseline_wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                              wd=[270] * self.full_ti.size, time=True)
        
        obs_values = []
        for t in range(len(self.full_ws)):
            this_sim = sim_res.isel(time=t, wt=0)
            observed_deficit = self.flow_roi.deficits.interp(
                ct=this_sim.CT, ti=this_sim.TI, z=0
            )
            obs_values.append(observed_deficit.T)
        
        self.all_obs = xr.concat(obs_values, dim='time')
        
    def _setup_optimization_bounds(self):
        """Setup parameter bounds and defaults based on model type and flow regime"""
        if not self.upstream:  # Downstream (wake)
            if self.model_type == 1:
                self.pbounds = {
                    'a_s': (0.001, 0.5), 'b_s': (0.001, 0.01), 'c_s': (0.001, 0.5),
                    'b_f': (-2, 1), 'c_f': (0.1, 5),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'a_s': 0.17, 'b_s': 0.005, 'c_s': 0.2, 'b_f': -0.68, 'c_f': 2.41,
                    'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.32
                }
            else:  # model_type == 2
                self.pbounds = {
                    'A': (0.001, .5), 'cti1': (.01, 5), 'cti2': (0.01, 5),
                    'ceps': (0.01, 3), 'ctlim': (0.01, 1),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'A': 0.04, 'cti1': 1.5, 'cti2': 0.8, 'ceps': 0.25, 'ctlim': 0.999,
                    'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.3
                }
        else:  # Upstream (blockage)
            self.pbounds = {
                'ss_alpha': (0.05, 3), 'ss_beta': (0.05, 3),
                'rp1': (-2, 2), 'rp2': (-2, 2),
                'ng1': (-3, 3), 'ng2': (-3, 3), 'ng3': (-3, 3), 'ng4': (-3, 3),
                'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
            }
            self.defaults = {
                'ss_alpha': 0.8888888888888888, 'ss_beta': 1.4142135623730951,
                'rp1': -0.672, 'rp2': 0.4897,
                'ng1': -1.381, 'ng2': 2.627, 'ng3': -1.524, 'ng4': 1.336,
                'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.32
            }
            
    def _create_wfm(self, params):
        """Create wind farm model with given parameters"""
        # Use defaults for missing parameters
        full_params = {**self.defaults, **params}
        
        # Turbulence model (always used)
        turb_args = {'c': np.array([full_params['ch1'], full_params['ch2'], 
                                   full_params['ch3'], full_params['ch4']])}
        
        if not self.upstream:  # Downstream (wake)
            if self.model_type == 1:
                wake_deficit = BlondelSuperGaussianDeficit2020(
                    a_s=full_params['a_s'], b_s=full_params['b_s'], c_s=full_params['c_s'],
                    b_f=full_params['b_f'], c_f=full_params['c_f']
                )
                blockage_deficit = SelfSimilarityDeficit2020(groundModel=Mirror())
            else:  # model_type == 2
                wake_deficit = TurboGaussianDeficit(
                    A=full_params['A'], 
                    cTI=[full_params['cti1'], full_params['cti2']],
                    ctlim=full_params['ctlim'], ceps=full_params['ceps'],
                    ct2a=ct2a_mom1d, groundModel=Mirror(),
                    rotorAvgModel=GaussianOverlapAvgModel()
                )
                wake_deficit.WS_key = 'WS_jlk'
                blockage_deficit = SelfSimilarityDeficit2020(groundModel=Mirror())
        else:  # Upstream (blockage)
            wake_deficit = BlondelSuperGaussianDeficit2020()
            blockage_args = {
                'ss_alpha': full_params['ss_alpha'], 'ss_beta': full_params['ss_beta'],
                'r12p': np.array([full_params['rp1'], full_params['rp2']]),
                'ngp': np.array([full_params['ng1'], full_params['ng2'], 
                               full_params['ng3'], full_params['ng4']])
            }
            if self.model_type == 2:
                blockage_args['groundModel'] = Mirror()
            blockage_deficit = SelfSimilarityDeficit2020(**blockage_args)
        
        return All2AllIterative(
            self.site, self.turbine,
            wake_deficitModel=wake_deficit,
            superpositionModel=LinearSum(), deflectionModel=None,
            turbulenceModel=CrespoHernandez(**turb_args),
            blockage_deficitModel=blockage_deficit
        )
    
    def evaluate_rmse(self, **kwargs):
        """Objective function for optimization"""
        try:
            wfm = self._create_wfm(kwargs)
            sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                         wd=[270] * self.full_ti.size, time=True)
            
            # Compute flow map for all time steps
            flow_map = None
            for tt in range(len(self.full_ws)):
                fm = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y), 
                                    time=[tt])['WS_eff']
                if flow_map is None:
                    flow_map = fm
                else:
                    flow_map = xr.concat([flow_map, fm], dim='time')
            
            # Convert model velocities to deficits for comparison
            pred_deficits = (sim_res.WS - flow_map.isel(h=0)) / sim_res.WS
            
            # Calculate RMSE
            rmse = float(np.sqrt(((self.all_obs - pred_deficits) ** 2).mean(['x', 'y'])).mean('time'))
            
            if np.isnan(rmse): 
                return -0.5
            return -rmse
            
        except Exception as e:
            print(f"Error in evaluation: {e}")
            return -0.5
    
    def optimize(self, init_points=50, n_iter=200):
        """Run Bayesian optimization"""
        self.optimizer = BayesianOptimization(
            f=self.evaluate_rmse, pbounds=self.pbounds, random_state=1
        )
        self.optimizer.probe(params=self.defaults, lazy=True)
        self.optimizer.maximize(init_points=init_points, n_iter=n_iter)
        
        self.best_params = self.optimizer.max['params']
        self.best_rmse = -self.optimizer.max['target']
        
        return self.best_params, self.best_rmse
    
    def create_optimization_animation(self, filename=None):
        """Create animation of optimization progress"""
        if filename is None:
            regime = "upstream" if self.upstream else "downstream"
            filename = f'optimization_animation_{regime}_model{self.model_type}.mp4'
        
        def update_plot(frame):
            ax1.clear()
            ax2.clear()
            
            best_so_far_params = {}
            best_so_far_rmse = float('inf')
            best_so_far_rmses = []
            
            for i in range(frame + 1):
                if -self.optimizer.space.target[i] <= best_so_far_rmse:
                    best_so_far_rmse = -self.optimizer.space.target[i]
                    best_so_far_params = self.optimizer.res[i]['params']
                best_so_far_rmses.append(best_so_far_rmse)
            
            ax1.plot(-np.array(self.optimizer.space.target), color='gray', alpha=0.5)
            ax1.plot(np.array(best_so_far_rmses), color='black')
            ax1.set_title('Optimization Convergence')
            ax1.set_xlabel('Iteration')
            ax1.set_ylabel('RMSE')
            ax1.grid(True)
            
            keys = list(best_so_far_params.keys())
            best_vals = [best_so_far_params[key] for key in keys]
            default_vals = [self.defaults[key] for key in keys]
            
            ax2.bar(keys, best_vals, label='Optimized')
            ax2.bar(keys, default_vals, edgecolor='black', linewidth=2, 
                   color='none', capstyle='butt', label='Default')
            ax2.set_title(f'Best RMSE: {best_so_far_rmse:.4f}')
            ax2.tick_params(axis='x', rotation=45)
            ax2.legend()
            plt.tight_layout()
            return ax1, ax2
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        ani = animation.FuncAnimation(fig, update_plot, 
                                    frames=len(self.optimizer.space.target), repeat=False)
        
        writer = animation.FFMpegWriter(fps=15)
        ani.save(filename, writer=writer)
        plt.close('all')
    
    def analyze_results(self, save_plots=True):
        """Analyze optimization results with improved error reporting"""
        # Create optimized model
        wfm = self._create_wfm(self.best_params)
        sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                     wd=[270] * self.full_ti.size, time=True)
        
        # Compute flow maps
        flow_map = None
        for tt in range(len(self.full_ws)):
            fm = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y), 
                                time=[tt])['WS_eff']
            if flow_map is None:
                flow_map = fm
            else:
                flow_map = xr.concat([flow_map, fm], dim='time')
        
        pred_deficits = (sim_res.WS - flow_map.isel(h=0)) / sim_res.WS
        
        # Calculate detailed error statistics
        errors = self.all_obs - pred_deficits
        rmse_per_time = np.sqrt((errors**2).mean(['x', 'y']))
        
        # Overall statistics
        overall_rmse = float(rmse_per_time.mean())
        overall_mae = float(np.abs(errors).mean())
        p90_error = float(np.percentile(np.abs(errors), 90))
        
        print(f"Overall RMSE: {overall_rmse:.4f}")
        print(f"Overall MAE: {overall_mae:.4f}")  
        print(f"P90 Absolute Error: {p90_error:.4f}")
        print(f"RMSE per time step - Mean: {float(rmse_per_time.mean()):.4f}, "
              f"Std: {float(rmse_per_time.std()):.4f}")
        
        if save_plots:
            self._create_result_plots(errors, pred_deficits, rmse_per_time)
        
        return {
            'overall_rmse': overall_rmse,
            'overall_mae': overall_mae, 
            'p90_error': p90_error,
            'rmse_per_time': rmse_per_time.values
        }
    
    def _create_result_plots(self, errors, pred_deficits, rmse_per_time):
        """Create result visualization plots"""
        regime = "upstream" if self.upstream else "downstream"
        
        # Time series error plot
        plt.figure(figsize=(10, 6))
        plt.plot(rmse_per_time, 'o-')
        plt.axhline(rmse_per_time.mean(), color='r', linestyle='--', 
                   label=f'Mean: {float(rmse_per_time.mean()):.4f}')
        plt.axhline(np.percentile(rmse_per_time, 90), color='orange', linestyle='--',
                   label=f'P90: {float(np.percentile(rmse_per_time, 90)):.4f}')
        plt.xlabel('Time Step')
        plt.ylabel('RMSE')
        plt.title(f'RMSE per Time Step - {regime.title()} Model {self.model_type}')
        plt.legend()
        plt.grid(True)
        plt.savefig(f'rmse_timeseries_{regime}_model{self.model_type}.png', dpi=150, bbox_inches='tight')
        plt.close()
        
        # Parameter comparison plot
        keys = list(self.best_params.keys())
        best_vals = [self.best_params[key] for key in keys]
        default_vals = [self.defaults[key] for key in keys]
        
        plt.figure(figsize=(12, 6))
        plt.bar(keys, best_vals, alpha=0.7, label='Optimized')
        plt.bar(keys, default_vals, edgecolor='black', linewidth=2, 
               color='none', capstyle='butt', label='Default')
        plt.title(f'Optimal RMSE: {self.best_rmse:.4f} - {regime.title()} Model {self.model_type}')
        plt.xticks(rotation=45)
        plt.legend()
        plt.tight_layout()
        plt.savefig(f'parameters_{regime}_model{self.model_type}.png', dpi=150, bbox_inches='tight')
        plt.close()
        
        # Sample flow field comparisons (first few time steps)
        for t in range(min(3, len(self.full_ws))):
            fig, axes = plt.subplots(2, 2, figsize=(12, 10))
            
            obs = self.all_obs.isel(time=t)
            pred = pred_deficits.isel(time=t)
            err = errors.isel(time=t)
            
            # Observations
            im1 = axes[0,0].contourf(self.target_x, self.target_y, obs, levels=20)
            axes[0,0].set_title('Observed Deficit')
            fig.colorbar(im1, ax=axes[0,0])
            
            # Predictions  
            im2 = axes[0,1].contourf(self.target_x, self.target_y, pred, levels=20)
            axes[0,1].set_title('Predicted Deficit')
            fig.colorbar(im2, ax=axes[0,1])
            
            # Error
            im3 = axes[1,0].contourf(self.target_x, self.target_y, err, levels=20, cmap='RdBu_r')
            axes[1,0].set_title(f'Error (RMSE: {float(rmse_per_time.isel(time=t)):.4f})')
            fig.colorbar(im3, ax=axes[1,0])
            
            # Error histogram
            axes[1,1].hist(err.values.flatten(), bins=30, alpha=0.7)
            axes[1,1].axvline(0, color='r', linestyle='--')
            axes[1,1].set_title('Error Distribution')
            axes[1,1].set_xlabel('Error')
            
            for ax in axes.flat:
                if hasattr(ax, 'set_aspect'):
                    ax.set_aspect('equal')
            
            plt.tight_layout()
            plt.savefig(f'flow_comparison_{regime}_model{self.model_type}_t{t}.png', 
                       dpi=150, bbox_inches='tight')
            plt.close()

# Usage example:
if __name__ == "__main__":
    # Downstream wake calibration with BlondelSuperGaussian
    calibrator = WakeModelCalibrator(model_type=1, upstream=False)
    best_params, best_rmse = calibrator.optimize(init_points=50, n_iter=200)
    
    print(f"Best parameters: {best_params}")
    print(f"Best RMSE: {best_rmse}")
    
    # Create animation and analyze results
    calibrator.create_optimization_animation()
    results = calibrator.analyze_results()
```

Key improvements in this rewrite:

1. **Modular Design**: Clean class structure with separate methods for each major function
2. **Consistent WFM Creation**: Single `_create_wfm()` method handles all model/regime combinations
3. **Better Error Reporting**: Now reports RMSE, MAE, P90 errors, and per-timestep statistics
4. **Fixed Deficit Comparison**: Converts model velocities to deficits before comparison
5. **Comprehensive Visualization**: Creates time series plots, parameter comparisons, and flow field analyses
6. **Robust Error Handling**: Better exception handling in optimization
7. **Flexible Usage**: Easy to switch between models and flow regimes

The class makes it much easier to run different configurations:
```python
# Upstream blockage with model 2
upstream_cal = WakeModelCalibrator(model_type=2, upstream=True)
upstream_cal.optimize()
upstream_cal.analyze_results()
```