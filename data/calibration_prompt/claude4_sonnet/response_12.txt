Looking at your code, I can see several issues and opportunities for improvement:

**Issues I notice:**
1. The flow field analysis is inconsistent - you're mixing velocity deficits and effective velocities
2. The WFM instantiation logic is scattered and repetitive 
3. Error reporting could be more comprehensive with averages and percentiles
4. The modular structure would make debugging and experimentation much easier

Here's a complete rewrite with better modularization:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import xarray as xr
from py_wake.rotor_avg_models.gaussian_overlap_model import GaussianOverlapAvgModel
from py_wake.deficit_models.gaussian import TurboGaussianDeficit
from py_wake.examples.data.dtu10mw._dtu10mw import DTU10MW
from py_wake.deficit_models.gaussian import BlondelSuperGaussianDeficit2020
from py_wake import HorizontalGrid
from py_wake.deflection_models import JimenezWakeDeflection
from py_wake.turbulence_models import CrespoHernandez
from py_wake.rotor_avg_models import RotorCenter
from py_wake.deficit_models import SelfSimilarityDeficit2020
from py_wake.wind_farm_models import PropagateDownwind, All2AllIterative
from py_wake.superposition_models import LinearSum
from py_wake.ground_models import Mirror
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from bayes_opt import BayesianOptimization
from py_wake.deficit_models.utils import ct2a_mom1d

class WakeModelOptimizer:
    def __init__(self, downstream=True, model=2):
        self.DOWNSTREAM = downstream
        self.MODEL = model
        self.setup_data()
        self.setup_conditions()
        self.setup_optimization_bounds()
        
    def setup_data(self):
        """Load and prepare reference data"""
        self.dat = xr.load_dataset('./DTU10MW.nc')
        self.turbine = DTU10MW()
        self.D = self.turbine.diameter()
        self.dat = self.dat.assign_coords(x=self.dat.x * self.D, y=self.dat.y * self.D)
        
        # Set ROI based on upstream/downstream
        if self.DOWNSTREAM:
            X_LB, X_UB = 2, 10
        else:
            X_LB, X_UB = -2, -1
            
        roi_x = slice(X_LB * self.D, X_UB * self.D)
        roi_y = slice(-2 * self.D, 2 * self.D)
        
        self.flow_roi = self.dat.sel(x=roi_x, y=roi_y)
        self.target_x = self.flow_roi.x
        self.target_y = self.flow_roi.y
        
    def setup_conditions(self):
        """Setup wind speed and turbulence intensity conditions"""
        TIs = np.arange(0.05, 0.45, 0.05)
        WSs = np.arange(4, 11)
        
        full_ti = [TIs for _ in range(WSs.size)]
        self.full_ti = np.array(full_ti).flatten()
        
        full_ws = [[WSs[ii]] * TIs.size for ii in range(WSs.size)]
        self.full_ws = np.array(full_ws).flatten()
        
        assert self.full_ws.size == self.full_ti.size
        
        # Setup site and reference simulation
        self.site = Hornsrev1Site()
        self.setup_reference_data()
        
    def setup_reference_data(self):
        """Create reference simulation and observed values"""
        ref_wfm = All2AllIterative(
            self.site, self.turbine,
            wake_deficitModel=BlondelSuperGaussianDeficit2020(),
            superpositionModel=LinearSum(), 
            deflectionModel=None,
            turbulenceModel=CrespoHernandez(),
            blockage_deficitModel=SelfSimilarityDeficit2020()
        )
        
        sim_res = ref_wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                         wd=[270] * self.full_ti.size, time=True)
        
        obs_values = []
        for t in range(len(self.full_ws)):
            this_pred_sim = sim_res.isel(time=t, wt=0)
            observed_deficit = self.flow_roi.deficits.interp(
                ct=this_pred_sim.CT, ti=this_pred_sim.TI, z=0
            )
            obs_values.append(observed_deficit.T)
            
        self.all_obs = xr.concat(obs_values, dim='time')
        
    def setup_optimization_bounds(self):
        """Setup parameter bounds and defaults for different model configurations"""
        if self.MODEL == 1:
            if self.DOWNSTREAM:
                self.pbounds = {
                    'a_s': (0.001, 0.5), 'b_s': (0.001, 0.01), 'c_s': (0.001, 0.5),
                    'b_f': (-2, 1), 'c_f': (0.1, 5),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'a_s': 0.17, 'b_s': 0.005, 'c_s': 0.2, 'b_f': -0.68, 'c_f': 2.41,
                    'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.32
                }
            else:
                self.pbounds = {
                    'ss_alpha': (0.05, 3), 'ss_beta': (0.05, 3),
                    'rp1': (-2, 2), 'rp2': (-2, 2),
                    'ng1': (-3, 3), 'ng2': (-3, 3), 'ng3': (-3, 3), 'ng4': (-3, 3),
                    'fg1': (-2, 2), 'fg2': (-2, 2), 'fg3': (-2, 2), 'fg4': (-2, 2)
                }
                self.defaults = {
                    'ss_alpha': 0.8888888888888888, 'ss_beta': 1.4142135623730951,
                    'rp1': -0.672, 'rp2': 0.4897,
                    'ng1': -1.381, 'ng2': 2.627, 'ng3': -1.524, 'ng4': 1.336,
                    'fg1': -0.06489, 'fg2': 0.4911, 'fg3': 1.116, 'fg4': -0.1577
                }
        else:  # MODEL == 2
            self.pbounds = {
                'A': (0.001, .5), 'cti1': (.01, 5), 'cti2': (0.01, 5),
                'ceps': (0.01, 3), 'ctlim': (0.01, 1),
                'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
            }
            self.defaults = {
                'A': 0.04, 'cti1': 1.5, 'cti2': 0.8, 'ceps': 0.25, 'ctlim': 0.999,
                'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.3
            }
    
    def create_wfm(self, **params):
        """Create wind farm model with given parameters"""
        # Default arguments
        wake_deficit_args = {}
        turbulence_args = {}
        blockage_args = {}
        
        if self.DOWNSTREAM:
            if self.MODEL == 1:
                wake_deficit_args = {k: params[k] for k in ['a_s', 'b_s', 'c_s', 'b_f', 'c_f']}
                wake_deficitModel = BlondelSuperGaussianDeficit2020(**wake_deficit_args)
            else:  # MODEL == 2
                wake_deficitModel = TurboGaussianDeficit(
                    A=params['A'], 
                    cTI=[params['cti1'], params['cti2']],
                    ctlim=params['ctlim'], 
                    ceps=params['ceps'],
                    ct2a=ct2a_mom1d,
                    groundModel=Mirror(),
                    rotorAvgModel=GaussianOverlapAvgModel()
                )
                wake_deficitModel.WS_key = 'WS_jlk'
            
            turbulence_args = {
                'c': np.array([params['ch1'], params['ch2'], params['ch3'], params['ch4']])
            }
        else:  # UPSTREAM
            wake_deficitModel = BlondelSuperGaussianDeficit2020()
            blockage_args = {
                'ss_alpha': params['ss_alpha'], 
                'ss_beta': params['ss_beta'],
                'r12p': np.array([params['rp1'], params['rp2']]),
                'ngp': np.array([params['ng1'], params['ng2'], params['ng3'], params['ng4']])
            }
            if self.MODEL == 2:
                blockage_args['groundModel'] = Mirror()
        
        return All2AllIterative(
            self.site, self.turbine,
            wake_deficitModel=wake_deficitModel,
            superpositionModel=LinearSum(), 
            deflectionModel=None,
            turbulenceModel=CrespoHernandez(**turbulence_args),
            blockage_deficitModel=SelfSimilarityDeficit2020(**blockage_args)
        )
    
    def evaluate_rmse(self, **params):
        """Evaluate RMSE for given parameters"""
        try:
            wfm = self.create_wfm(**params)
            sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                         wd=[270] * self.full_ti.size, time=True)
            
            # Calculate velocity deficits consistently
            flow_maps = []
            for tt in range(len(self.full_ws)):
                fm = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y), time=[tt])
                # Convert effective velocity to deficit
                ws_ref = sim_res.WS.isel(time=tt, wt=0)
                deficit = (ws_ref - fm.WS_eff.isel(h=0)) / ws_ref
                flow_maps.append(deficit)
            
            pred_deficits = xr.concat(flow_maps, dim='time')
            
            # Calculate RMSE
            rmse = float(np.sqrt(((self.all_obs - pred_deficits) ** 2).mean(['x', 'y'])).mean('time'))
            
            if np.isnan(rmse):
                return -0.5
            return -rmse
            
        except Exception as e:
            print(f"Error in evaluation: {e}")
            return -0.5
    
    def optimize(self, init_points=50, n_iter=200):
        """Run Bayesian optimization"""
        self.optimizer = BayesianOptimization(f=self.evaluate_rmse, pbounds=self.pbounds, random_state=1)
        self.optimizer.probe(params=self.defaults, lazy=True)
        self.optimizer.maximize(init_points=init_points, n_iter=n_iter)
        
        self.best_params = self.optimizer.max['params']
        self.best_rmse = -self.optimizer.max['target']
        
        return self.best_params, self.best_rmse
    
    def create_optimization_animation(self, filename):
        """Create optimization convergence animation"""
        def update_plot(frame):
            ax1.clear()
            ax2.clear()
            
            best_so_far_rmse = float('inf')
            best_so_far_rmses = []
            best_so_far_params = {}
            
            for i in range(frame + 1):
                if -self.optimizer.space.target[i] <= best_so_far_rmse:
                    best_so_far_rmse = -self.optimizer.space.target[i]
                    best_so_far_params = self.optimizer.res[i]['params']
                best_so_far_rmses.append(best_so_far_rmse)
            
            # Plot convergence
            ax1.plot(-np.array(self.optimizer.space.target), color='gray', alpha=0.5)
            ax1.plot(np.array(best_so_far_rmses), color='black')
            ax1.set_title('Optimization Convergence')
            ax1.set_xlabel('Iteration')
            ax1.set_ylabel('RMSE')
            ax1.grid(True)
            
            # Plot parameters
            keys = list(best_so_far_params.keys())
            best_vals = [best_so_far_params[key] for key in keys]
            default_vals = [self.defaults[key] for key in keys]
            
            ax2.bar(keys, best_vals, label='Optimized')
            ax2.bar(keys, default_vals, edgecolor='black', linewidth=2, 
                   color='none', capstyle='butt', label='Default')
            ax2.set_title(f'Best RMSE: {best_so_far_rmse:.4f}')
            ax2.tick_params(axis='x', rotation=45)
            ax2.legend()
            plt.tight_layout()
            
            return ax1, ax2
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        ani = animation.FuncAnimation(fig, update_plot, frames=len(self.optimizer.space.target), repeat=False)
        
        writer = animation.FFMpegWriter(fps=15)
        ani.save(filename, writer=writer)
        plt.close('all')
    
    def analyze_results(self, save_figs=True):
        """Analyze and visualize results with comprehensive error reporting"""
        wfm = self.create_wfm(**self.best_params)
        sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                     wd=[270] * self.full_ti.size, time=True)
        
        rmse_values = []
        mae_values = []
        all_errors = []
        
        for t in range(len(self.full_ws)):
            # Get observed deficit
            this_pred_sim = sim_res.isel(time=t, wt=0)
            observed_deficit = self.flow_roi.deficits.interp(
                ct=this_pred_sim.CT, ti=this_pred_sim.TI, z=0
            )
            
            # Calculate predicted deficit
            fm = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y), time=[t])
            ws_ref = this_pred_sim.WS
            pred_deficit = (ws_ref - fm.WS_eff.isel(h=0)) / ws_ref
            
            # Calculate errors
            diff = observed_deficit.T - pred_deficit
            all_errors.extend(diff.values.flatten())
            
            rmse = np.sqrt(np.mean(diff**2))
            mae = np.mean(np.abs(diff))
            rmse_values.append(rmse)
            mae_values.append(mae)
            
            if save_figs:
                # Create comparison plots
                fig, ax = plt.subplots(3, 1, figsize=(8, 12))
                
                vmin, vmax = min(observed_deficit.min(), pred_deficit.min()), max(observed_deficit.max(), pred_deficit.max())
                
                co = ax[0].contourf(self.target_x, self.target_y, observed_deficit.T, levels=20, vmin=vmin, vmax=vmax)
                ax[0].set_title('Observed Deficit')
                fig.colorbar(co, ax=ax[0])
                
                cp = ax[1].contourf(self.target_x, self.target_y, pred_deficit, levels=20, vmin=vmin, vmax=vmax)
                ax[1].set_title('Predicted Deficit')
                fig.colorbar(cp, ax=ax[1])
                
                cd = ax[2].contourf(self.target_x, self.target_y, diff, levels=20, cmap='RdBu_r')
                ax[2].set_title(f'Difference (RMSE: {rmse:.4f}, MAE: {mae:.4f})')
                fig.colorbar(cd, ax=ax[2])
                
                for a in ax:
                    a.set_xlabel('x [m]')
                    a.set_ylabel('y [m]')
                
                plt.tight_layout()
                plt.savefig(f'figs/flow_field_comparison_{t:02d}.png', dpi=150, bbox_inches='tight')
                plt.close()
        
        # Calculate comprehensive error statistics
        all_errors = np.array(all_errors)
        error_stats = {
            'mean_rmse': np.mean(rmse_values),
            'std_rmse': np.std(rmse_values),
            'mean_mae': np.mean(mae_values),
            'std_mae': np.std(mae_values),
            'mean_error': np.mean(all_errors),
            'p90_error': np.percentile(np.abs(all_errors), 90),
            'p95_error': np.percentile(np.abs(all_errors), 95),
            'max_error': np.max(np.abs(all_errors))
        }
        
        # Print comprehensive results
        print("="*60)
        print("OPTIMIZATION RESULTS")
        print("="*60)
        print(f"Best RMSE: {self.best_rmse:.6f}")
        print(f"Mean RMSE across time steps: {error_stats['mean_rmse']:.6f} ± {error_stats['std_rmse']:.6f}")
        print(f"Mean MAE across time steps: {error_stats['mean_mae']:.6f} ± {error_stats['std_mae']:.6f}")
        print(f"Mean error (bias): {error_stats['mean_error']:.6f}")
        print(f"P90 absolute error: {error_stats['p90_error']:.6f}")
        print(f"P95 absolute error: {error_stats['p95_error']:.6f}")
        print(f"Maximum absolute error: {error_stats['max_error']:.6f}")
        print("="*60)
        
        # Create parameter comparison plot
        if save_figs:
            keys = list(self.best_params.keys())
            best_vals = [self.best_params[key] for key in keys]
            default_vals = [self.defaults[key] for key in keys]
            
            plt.figure(figsize=(12, 6))
            plt.bar(keys, best_vals, alpha=0.7, label='Optimized')
            plt.bar(keys, default_vals, edgecolor='black', linewidth=2, 
                   color='none', capstyle='butt', label='Default')
            plt.title(f'Parameter Comparison (RMSE: {self.best_rmse:.6f})')
            plt.xticks(rotation=45)
            plt.legend()
            plt.tight_layout()
            plt.savefig(f'parameter_comparison_{"downstream" if self.DOWNSTREAM else "upstream"}_model{self.MODEL}.png', 
                       dpi=150, bbox_inches='tight')
            plt.close()
        
        return error_stats

# Usage example
if __name__ == "__main__":
    # Configuration
    DOWNSTREAM = True  # True for downstream, False for upstream
    MODEL = 2  # 1 or 2
    
    # Create optimizer
    optimizer = WakeModelOptimizer(downstream=DOWNSTREAM, model=MODEL)
    
    # Run optimization
    print("Starting optimization...")
    best_params, best_rmse = optimizer.optimize(init_points=50, n_iter=200)
    
    # Create animation
    region = "downstream" if DOWNSTREAM else "upstream"
    optimizer.create_optimization_animation(f'optimization_animation_{region}_model{MODEL}.mp4')
    
    # Analyze results
    import os
    os.makedirs('figs', exist_ok=True)
    error_stats = optimizer.analyze_results(save_figs=True)
```

**Key improvements in this rewrite:**

1. **Modular Design**: Everything is encapsulated in a class with clear separation of concerns
2. **Consistent Deficit Calculation**: Fixed the velocity vs deficit confusion 
3. **Comprehensive Error Reporting**: Added mean, std, p90, p95, and max absolute errors
4. **Better Flow Field Plots**: Fixed the deficit calculation and added proper color scaling
5. **Cleaner WFM Instantiation**: Single `create_wfm()` method handles all model configurations
6. **Robust Error Handling**: Better exception handling in the evaluation function
7. **Improved Visualization**: Better plots with proper labels and statistics
8. **Flexible Configuration**: Easy to switch between upstream/downstream and different models

The key fix for your flow field issue is in the `analyze_results()` method where I properly convert `flow_map.WS_eff` to deficits by comparing with the reference wind speed, making it consistent with your reference data format.