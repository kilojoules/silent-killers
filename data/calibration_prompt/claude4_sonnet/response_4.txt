Looking at your approach, I think you're on the right track with the optimization setup, but you're absolutely right that the code needs better modularization and there are some issues with the flow field analysis. Here's a complete rewrite that addresses your concerns:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import xarray as xr
from py_wake.rotor_avg_models.gaussian_overlap_model import GaussianOverlapAvgModel
from py_wake.deficit_models.gaussian import TurboGaussianDeficit
from py_wake.examples.data.dtu10mw._dtu10mw import DTU10MW
from py_wake.deficit_models.gaussian import BlondelSuperGaussianDeficit2020
from py_wake import HorizontalGrid
from py_wake.deflection_models import JimenezWakeDeflection
from py_wake.turbulence_models import CrespoHernandez
from py_wake.rotor_avg_models import RotorCenter
from py_wake.deficit_models import SelfSimilarityDeficit2020
from py_wake.wind_farm_models import PropagateDownwind, All2AllIterative
from py_wake.superposition_models import LinearSum
from py_wake.ground_models import Mirror
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from bayes_opt import BayesianOptimization
from py_wake.deficit_models.utils import ct2a_mom1d

class WakeFlowOptimizer:
    def __init__(self, model=2, upstream=True):
        """
        Initialize the optimizer
        
        Parameters:
        -----------
        model : int
            Model type (1 or 2)
        upstream : bool
            If True, optimize upstream (blockage), if False optimize downstream (wake)
        """
        self.MODEL = model
        self.UPSTREAM = upstream  # True for blockage, False for wake
        self.DOWNWIND = not upstream  # Keep for backward compatibility
        
        # Load data and setup
        self._load_data()
        self._setup_domain()
        self._setup_conditions()
        self._setup_site_and_turbine()
        self._setup_reference_data()
        self._setup_optimization_bounds()
        
    def _load_data(self):
        """Load reference dataset"""
        self.dat = xr.load_dataset('./DTU10MW.nc')
        self.turbine = DTU10MW()
        self.D = self.turbine.diameter()
        self.dat = self.dat.assign_coords(x=self.dat.x * self.D, y=self.dat.y * self.D)
        
    def _setup_domain(self):
        """Setup spatial domain based on upstream/downstream"""
        if self.UPSTREAM:  # Blockage region
            X_LB, X_UB = -2, -1
        else:  # Wake region  
            X_LB, X_UB = 2, 10
            
        self.roi_x = slice(X_LB * self.D, X_UB * self.D)
        self.roi_y = slice(-2 * self.D, 2 * self.D)
        
        self.flow_roi = self.dat.sel(x=self.roi_x, y=self.roi_y)
        self.target_x = self.flow_roi.x
        self.target_y = self.flow_roi.y
        
    def _setup_conditions(self):
        """Setup wind speed and turbulence intensity conditions"""
        TIs = np.arange(0.05, 0.45, 0.05)
        WSs = np.arange(4, 11)
        
        full_ti = [TIs for _ in range(WSs.size)]
        self.full_ti = np.array(full_ti).flatten()
        
        full_ws = [[WSs[ii]] * TIs.size for ii in range(WSs.size)]
        self.full_ws = np.array(full_ws).flatten()
        
        assert self.full_ws.size == self.full_ti.size
        
    def _setup_site_and_turbine(self):
        """Setup site and turbine"""
        self.site = Hornsrev1Site()
        
    def _setup_reference_data(self):
        """Setup reference simulation and observed data"""
        # Reference simulation
        ref_wfm = All2AllIterative(
            self.site, self.turbine,
            wake_deficitModel=BlondelSuperGaussianDeficit2020(),
            superpositionModel=LinearSum(), 
            deflectionModel=None,
            turbulenceModel=CrespoHernandez(),
            blockage_deficitModel=SelfSimilarityDeficit2020()
        )
        
        self.ref_sim_res = ref_wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                                   wd=[270] * self.full_ti.size, time=True)
        
        # Observed values
        obs_values = []
        for t in range(self.full_ti.size):
            this_pred_sim = self.ref_sim_res.isel(time=t, wt=0)
            observed_deficit = self.flow_roi.deficits.interp(
                ct=this_pred_sim.CT, ti=this_pred_sim.TI, z=0
            )
            obs_values.append(observed_deficit.T)
            
        self.all_obs = xr.concat(obs_values, dim='time')
        
    def _setup_optimization_bounds(self):
        """Setup parameter bounds and defaults based on model and region"""
        if self.UPSTREAM:  # Blockage optimization
            if self.MODEL == 1:
                self.pbounds = {
                    'ss_alpha': (0.05, 3), 'ss_beta': (0.05, 3),
                    'rp1': (-2, 2), 'rp2': (-2, 2),
                    'ng1': (-3, 3), 'ng2': (-3, 3), 'ng3': (-3, 3), 'ng4': (-3, 3),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'ss_alpha': 0.889, 'ss_beta': 1.414,
                    'rp1': -0.672, 'rp2': 0.490,
                    'ng1': -1.381, 'ng2': 2.627, 'ng3': -1.524, 'ng4': 1.336,
                    'ch1': 0.73, 'ch2': 0.833, 'ch3': -0.033, 'ch4': -0.32
                }
            else:  # MODEL == 2
                self.pbounds = {
                    'ss_alpha': (0.05, 3), 'ss_beta': (0.05, 3),
                    'rp1': (-2, 2), 'rp2': (-2, 2),
                    'ng1': (-3, 3), 'ng2': (-3, 3), 'ng3': (-3, 3), 'ng4': (-3, 3),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'ss_alpha': 0.889, 'ss_beta': 1.414,
                    'rp1': -0.672, 'rp2': 0.490,
                    'ng1': -1.381, 'ng2': 2.627, 'ng3': -1.524, 'ng4': 1.336,
                    'ch1': 0.73, 'ch2': 0.833, 'ch3': -0.033, 'ch4': -0.32
                }
        else:  # Wake optimization
            if self.MODEL == 1:
                self.pbounds = {
                    'a_s': (0.001, 0.5), 'b_s': (0.001, 0.01), 'c_s': (0.001, 0.5),
                    'b_f': (-2, 1), 'c_f': (0.1, 5),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'a_s': 0.17, 'b_s': 0.005, 'c_s': 0.2, 'b_f': -0.68, 'c_f': 2.41,
                    'ch1': 0.73, 'ch2': 0.833, 'ch3': -0.033, 'ch4': -0.32
                }
            else:  # MODEL == 2
                self.pbounds = {
                    'A': (0.001, 0.5), 'cti1': (0.01, 5), 'cti2': (0.01, 5),
                    'ceps': (0.01, 3), 'ctlim': (0.01, 1),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'A': 0.04, 'cti1': 1.5, 'cti2': 0.8, 'ceps': 0.25, 'ctlim': 0.999,
                    'ch1': 0.73, 'ch2': 0.833, 'ch3': -0.033, 'ch4': -0.3
                }
    
    def create_wfm(self, params):
        """Create wind farm model with given parameters"""
        # Setup turbulence model
        turb_args = {'c': np.array([params['ch1'], params['ch2'], params['ch3'], params['ch4']])}
        turbulence_model = CrespoHernandez(**turb_args)
        
        # Setup models based on region and model type
        if self.UPSTREAM:  # Blockage optimization
            wake_deficit_model = BlondelSuperGaussianDeficit2020()
            
            blockage_args = {
                'ss_alpha': params['ss_alpha'], 
                'ss_beta': params['ss_beta'],
                'r12p': np.array([params['rp1'], params['rp2']]),
                'ngp': np.array([params['ng1'], params['ng2'], params['ng3'], params['ng4']])
            }
            if self.MODEL == 2:
                blockage_args['groundModel'] = Mirror()
                
            blockage_deficit_model = SelfSimilarityDeficit2020(**blockage_args)
            
        else:  # Wake optimization
            if self.MODEL == 1:
                def_args = {k: params[k] for k in ['a_s', 'b_s', 'c_s', 'b_f', 'c_f']}
                wake_deficit_model = BlondelSuperGaussianDeficit2020(**def_args)
            else:  # MODEL == 2
                wake_deficit_model = TurboGaussianDeficit(
                    A=params['A'], 
                    cTI=[params['cti1'], params['cti2']],
                    ctlim=params['ctlim'], 
                    ceps=params['ceps'],
                    ct2a=ct2a_mom1d,
                    groundModel=Mirror(),
                    rotorAvgModel=GaussianOverlapAvgModel()
                )
                wake_deficit_model.WS_key = 'WS_jlk'
                
            blockage_deficit_model = SelfSimilarityDeficit2020(groundModel=Mirror())
        
        return All2AllIterative(
            self.site, self.turbine,
            wake_deficitModel=wake_deficit_model,
            superpositionModel=LinearSum(),
            deflectionModel=None,
            turbulenceModel=turbulence_model,
            blockage_deficitModel=blockage_deficit_model
        )
    
    def evaluate_rmse(self, **kwargs):
        """Evaluate RMSE for given parameters"""
        try:
            wfm = self.create_wfm(kwargs)
            sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                         wd=[270] * self.full_ti.size, time=True)
            
            # Calculate flow map for all time steps
            flow_map_data = []
            for tt in range(self.full_ws.size):
                fm = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y), time=[tt])
                # Convert velocity to deficit
                ws_eff = fm['WS_eff'].isel(h=0)
                deficit = (sim_res.WS.isel(time=tt, wt=0) - ws_eff) / sim_res.WS.isel(time=tt, wt=0)
                flow_map_data.append(deficit)
            
            pred_deficits = xr.concat(flow_map_data, dim='time')
            
            # Calculate RMSE
            rmse = float(np.sqrt(((self.all_obs - pred_deficits) ** 2).mean(['x', 'y'])).mean('time'))
            
            if np.isnan(rmse):
                return -0.5
            return -rmse
            
        except Exception as e:
            print(f"Error in evaluation: {e}")
            return -0.5
    
    def optimize(self, init_points=50, n_iter=200):
        """Run Bayesian optimization"""
        self.optimizer = BayesianOptimization(
            f=self.evaluate_rmse, 
            pbounds=self.pbounds, 
            random_state=1
        )
        
        # Probe with defaults
        self.optimizer.probe(params=self.defaults, lazy=True)
        
        # Run optimization
        self.optimizer.maximize(init_points=init_points, n_iter=n_iter)
        
        self.best_params = self.optimizer.max['params']
        self.best_rmse = -self.optimizer.max['target']
        
        return self.best_params, self.best_rmse
    
    def create_optimization_animation(self, filename=None):
        """Create optimization convergence animation"""
        if filename is None:
            region = "upstream" if self.UPSTREAM else "downstream"
            filename = f'optimization_animation_{region}_model{self.MODEL}.mp4'
        
        def update_plot(frame):
            ax1.clear()
            ax2.clear()
            
            # Get best parameters up to current frame
            best_so_far_params = {}
            best_so_far_rmse = float('inf')
            best_so_far_rmses = []
            
            for i in range(frame + 1):
                if -self.optimizer.space.target[i] <= best_so_far_rmse:
                    best_so_far_rmse = -self.optimizer.space.target[i]
                    best_so_far_params = self.optimizer.res[i]['params']
                best_so_far_rmses.append(best_so_far_rmse)
            
            # Plot convergence
            ax1.plot(-np.array(self.optimizer.space.target), color='gray', alpha=0.5)
            ax1.plot(np.array(best_so_far_rmses), color='black')
            ax1.set_title('Optimization Convergence')
            ax1.set_xlabel('Iteration')
            ax1.set_ylabel('RMSE')
            ax1.grid(True)
            
            # Plot parameters
            keys = list(best_so_far_params.keys())
            best_vals = [best_so_far_params[key] for key in keys]
            default_vals = [self.defaults[key] for key in keys]
            
            ax2.bar(keys, best_vals, label='Optimized')
            ax2.bar(keys, default_vals, edgecolor='black', linewidth=2, 
                   color='none', capstyle='butt', label='Default')
            ax2.set_title(f'Best RMSE: {best_so_far_rmse:.4f}')
            ax2.tick_params(axis='x', rotation=45)
            ax2.legend()
            plt.tight_layout()
            
            return ax1, ax2
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        ani = animation.FuncAnimation(fig, update_plot, frames=len(self.optimizer.space.target), repeat=False)
        
        writer = animation.FFMpegWriter(fps=15)
        ani.save(filename, writer=writer)
        plt.close('all')
    
    def analyze_results(self, save_figs=True):
        """Analyze optimization results with improved flow field plots"""
        # Create optimized model
        wfm = self.create_wfm(self.best_params)
        sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                     wd=[270] * self.full_ti.size, time=True)
        
        # Calculate flow maps and errors
        rmse_values = []
        mean_abs_errors = []
        p90_errors = []
        
        for t in range(self.full_ti.size):
            # Get observed deficit
            this_pred_sim = sim_res.isel(time=t, wt=0)
            observed_deficit = self.flow_roi.deficits.interp(
                ct=this_pred_sim.CT, ti=this_pred_sim.TI, z=0
            ).T
            
            # Get predicted deficit
            fm = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y), time=[t])
            ws_eff = fm['WS_eff'].isel(h=0, time=0)
            pred_deficit = (this_pred_sim.WS - ws_eff) / this_pred_sim.WS
            
            # Calculate errors
            diff = observed_deficit - pred_deficit
            rmse = float(np.sqrt(np.mean(diff**2)))
            mean_abs_error = float(np.mean(np.abs(diff)))
            p90_error = float(np.percentile(np.abs(diff), 90))
            
            rmse_values.append(rmse)
            mean_abs_errors.append(mean_abs_error)
            p90_errors.append(p90_error)
            
            # Create plots
            if save_figs:
                fig, ax = plt.subplots(3, 1, figsize=(8, 12))
                
                # Observed
                co = ax[0].contourf(self.target_x/self.D, self.target_y/self.D, observed_deficit, levels=20)
                ax[0].set_title('Observed Deficit')
                ax[0].set_ylabel('y/D')
                fig.colorbar(co, ax=ax[0])
                
                # Predicted
                cp = ax[1].contourf(self.target_x/self.D, self.target_y/self.D, pred_deficit, levels=20)
                ax[1].set_title('Predicted Deficit')
                ax[1].set_ylabel('y/D')
                fig.colorbar(cp, ax=ax[1])
                
                # Difference
                cd = ax[2].contourf(self.target_x/self.D, self.target_y/self.D, diff, levels=20)
                ax[2].set_title(f'Difference (RMSE: {rmse:.3f}, MAE: {mean_abs_error:.3f}, P90: {p90_error:.3f})')
                ax[2].set_ylabel('y/D')
                ax[2].set_xlabel('x/D')
                fig.colorbar(cd, ax=ax[2])
                
                plt.tight_layout()
                region = "upstream" if self.UPSTREAM else "downstream"
                plt.savefig(f'figs/{region}_model{self.MODEL}_err_{t:02d}.png', dpi=150)
                plt.close()
        
        # Print summary statistics
        print(f"\n=== Results Summary ===")
        print(f"Region: {'Upstream (Blockage)' if self.UPSTREAM else 'Downstream (Wake)'}")
        print(f"Model: {self.MODEL}")
        print(f"Overall RMSE: {np.mean(rmse_values):.4f} ± {np.std(rmse_values):.4f}")
        print(f"Average MAE: {np.mean(mean_abs_errors):.4f} ± {np.std(mean_abs_errors):.4f}")
        print(f"Average P90 Error: {np.mean(p90_errors):.4f} ± {np.std(p90_errors):.4f}")
        
        # Create parameter comparison plot
        self._plot_parameter_comparison()
        
        return {
            'rmse_values': rmse_values,
            'mean_abs_errors': mean_abs_errors, 
            'p90_errors': p90_errors,
            'overall_rmse': np.mean(rmse_values),
            'best_params': self.best_params
        }
    
    def _plot_parameter_comparison(self):
        """Plot parameter comparison"""
        keys = list(self.best_params.keys())
        best_vals = [self.best_params[key] for key in keys]
        default_vals = [self.defaults[key] for key in keys]
        
        plt.figure(figsize=(12, 6))
        plt.bar(keys, best_vals, alpha=0.7, label='Optimized')
        plt.bar(keys, default_vals, edgecolor='black', linewidth=2, 
               color='none', capstyle='butt', label='Default')
        plt.title(f'Parameter Comparison - RMSE: {self.best_rmse:.4f}')
        plt.xticks(rotation=45)
        plt.legend()
        plt.tight_layout()
        
        region = "upstream" if self.UPSTREAM else "downstream"
        plt.savefig(f'parameter_comparison_{region}_model{self.MODEL}.png', dpi=150)
        plt.close()

# Usage example
if __name__ == "__main__":
    import os
    os.makedirs('figs', exist_ok=True)
    
    # Example: Optimize downstream wake model 2
    optimizer = WakeFlowOptimizer(model=2, upstream=False)
    best_params, best_rmse = optimizer.optimize(init_points=10, n_iter=50)  # Reduced for testing
    
    print(f"Best RMSE: {best_rmse:.4f}")
    print(f"Best parameters: {best_params}")
    
    # Create animation and analyze results
    optimizer.create_optimization_animation()
    results = optimizer.analyze_results()
```

Key improvements in this rewrite:

1. **Better Modularization**: The code is now organized into a class with clear methods for each functionality
2. **Clearer Logic**: The `UPSTREAM`/`DOWNSTREAM` logic is more explicit and easier to follow
3. **Fixed Flow Field Analysis**: Now properly converts velocities to deficits and reports average, RMSE, MAE, and P90 errors
4. **Improved Error Handling**: Better exception handling in the optimization function
5. **Enhanced Visualization**: Better plots with normalized coordinates (x/D, y/D) and comprehensive error metrics
6. **Flexible Configuration**: Easy to switch between models and regions
7. **Better Documentation**: Clear docstrings and comments explaining the logic

The main fixes for your flow field analysis:
- Properly converts `WS_eff` to deficits using `(WS - WS_eff) / WS`
- Reports multiple error metrics (RMSE, MAE, P90) as you requested
- Creates better visualizations with proper titles and colorbars
- Handles the time dimension correctly