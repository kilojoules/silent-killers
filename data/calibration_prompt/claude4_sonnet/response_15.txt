Looking at your code, I can see you're doing wake model optimization with Bayesian optimization. Your approach is solid, but I agree that a rewrite would help with modularity and clarity. Here's a refactored version:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import xarray as xr
from py_wake.rotor_avg_models.gaussian_overlap_model import GaussianOverlapAvgModel
from py_wake.deficit_models.gaussian import TurboGaussianDeficit
from py_wake.examples.data.dtu10mw._dtu10mw import DTU10MW
from py_wake.deficit_models.gaussian import BlondelSuperGaussianDeficit2020
from py_wake import HorizontalGrid
from py_wake.deflection_models import JimenezWakeDeflection
from py_wake.turbulence_models import CrespoHernandez
from py_wake.rotor_avg_models import RotorCenter
from py_wake.deficit_models import SelfSimilarityDeficit2020
from py_wake.wind_farm_models import PropagateDownwind, All2AllIterative
from py_wake.superposition_models import LinearSum
from py_wake.ground_models import Mirror
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from bayes_opt import BayesianOptimization
from py_wake.deficit_models.utils import ct2a_mom1d

class WakeModelOptimizer:
    def __init__(self, model=2, upstream=False):
        self.MODEL = model
        self.UPSTREAM = upstream
        self.DOWNWIND = not upstream
        
        # Load data and setup
        self.dat = xr.load_dataset('./DTU10MW.nc')
        self.turbine = DTU10MW()
        self.D = self.turbine.diameter()
        self.dat = self.dat.assign_coords(x=self.dat.x * self.D, y=self.dat.y * self.D)
        self.site = Hornsrev1Site()
        
        # Setup ROI
        self._setup_roi()
        
        # Setup wind conditions
        self._setup_wind_conditions()
        
        # Setup optimization parameters
        self._setup_optimization_params()
        
        # Prepare reference data
        self._prepare_reference_data()
    
    def _setup_roi(self):
        """Setup region of interest based on upstream/downstream"""
        if self.DOWNWIND:
            X_LB, X_UB = 2, 10
        else:
            X_LB, X_UB = -2, -1
        
        self.X_LB, self.X_UB = X_LB, X_UB
        roi_x = slice(X_LB * self.D, X_UB * self.D)
        roi_y = slice(-2 * self.D, 2 * self.D)
        
        self.flow_roi = self.dat.sel(x=roi_x, y=roi_y)
        self.target_x = self.flow_roi.x
        self.target_y = self.flow_roi.y
    
    def _setup_wind_conditions(self):
        """Setup wind speed and turbulence intensity conditions"""
        TIs = np.arange(0.05, 0.45, 0.05)
        WSs = np.arange(4, 11)
        
        full_ti = [TIs for _ in range(WSs.size)]
        self.full_ti = np.array(full_ti).flatten()
        
        full_ws = [[WSs[ii]] * TIs.size for ii in range(WSs.size)]
        self.full_ws = np.array(full_ws).flatten()
    
    def _setup_optimization_params(self):
        """Setup parameter bounds and defaults for optimization"""
        if self.MODEL == 1:
            if self.DOWNWIND:
                self.pbounds = {
                    'a_s': (0.001, 0.5), 'b_s': (0.001, 0.01), 'c_s': (0.001, 0.5),
                    'b_f': (-2, 1), 'c_f': (0.1, 5),
                    'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
                }
                self.defaults = {
                    'a_s': 0.17, 'b_s': 0.005, 'c_s': 0.2, 'b_f': -0.68, 'c_f': 2.41,
                    'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.32
                }
            else:
                self.pbounds = {
                    'ss_alpha': (0.05, 3), 'ss_beta': (0.05, 3),
                    'rp1': (-2, 2), 'rp2': (-2, 2),
                    'ng1': (-3, 3), 'ng2': (-3, 3), 'ng3': (-3, 3), 'ng4': (-3, 3),
                    'fg1': (-2, 2), 'fg2': (-2, 2), 'fg3': (-2, 2), 'fg4': (-2, 2)
                }
                self.defaults = {
                    'ss_alpha': 0.8888888888888888, 'ss_beta': 1.4142135623730951,
                    'rp1': -0.672, 'rp2': 0.4897,
                    'ng1': -1.381, 'ng2': 2.627, 'ng3': -1.524, 'ng4': 1.336,
                    'fg1': -0.06489, 'fg2': 0.4911, 'fg3': 1.116, 'fg4': -0.1577
                }
        else:  # MODEL == 2
            self.pbounds = {
                'A': (0.001, .5), 'cti1': (.01, 5), 'cti2': (0.01, 5),
                'ceps': (0.01, 3), 'ctlim': (0.01, 1),
                'ch1': (-1, 2), 'ch2': (-1, 2), 'ch3': (-1, 2), 'ch4': (-1, 2),
            }
            self.defaults = {
                'A': 0.04, 'cti1': 1.5, 'cti2': 0.8, 'ceps': 0.25, 'ctlim': 0.999,
                'ch1': 0.73, 'ch2': 0.8325, 'ch3': -0.0325, 'ch4': -0.3
            }
    
    def _prepare_reference_data(self):
        """Prepare reference simulation data"""
        sim_res = All2AllIterative(
            self.site, self.turbine,
            wake_deficitModel=BlondelSuperGaussianDeficit2020(),
            superpositionModel=LinearSum(),
            deflectionModel=None,
            turbulenceModel=CrespoHernandez(),
            blockage_deficitModel=SelfSimilarityDeficit2020()
        )([0], [0], ws=self.full_ws, TI=self.full_ti, wd=[270] * self.full_ti.size, time=True)
        
        obs_values = []
        for t in range(sim_res.time.size):
            this_pred_sim = sim_res.isel(time=t, wt=0)
            observed_deficit = self.flow_roi.deficits.interp(
                ct=this_pred_sim.CT, ti=this_pred_sim.TI, z=0
            )
            obs_values.append(observed_deficit.T)
        
        self.all_obs = xr.concat(obs_values, dim='time')
    
    def _create_wake_farm_model(self, **kwargs):
        """Create wind farm model based on parameters"""
        # Initialize arguments
        def_args = {}
        turb_args = {}
        blockage_args = {}
        
        if self.DOWNWIND:
            if self.MODEL == 1:
                def_args = {k: kwargs[k] for k in ['a_s', 'b_s', 'c_s', 'b_f', 'c_f']}
                wake_deficitModel = BlondelSuperGaussianDeficit2020(**def_args)
            else:  # MODEL == 2
                wake_deficitModel = TurboGaussianDeficit(
                    A=kwargs['A'], 
                    cTI=[kwargs['cti1'], kwargs['cti2']],
                    ctlim=kwargs['ctlim'], 
                    ceps=kwargs['ceps'],
                    ct2a=ct2a_mom1d,
                    groundModel=Mirror(),
                    rotorAvgModel=GaussianOverlapAvgModel()
                )
                wake_deficitModel.WS_key = 'WS_jlk'
            
            turb_args = {'c': np.array([kwargs['ch1'], kwargs['ch2'], kwargs['ch3'], kwargs['ch4']])}
        
        else:  # UPSTREAM
            wake_deficitModel = BlondelSuperGaussianDeficit2020(**def_args)
            blockage_args = {
                'ss_alpha': kwargs['ss_alpha'], 
                'ss_beta': kwargs['ss_beta'], 
                'r12p': np.array([kwargs['rp1'], kwargs['rp2']]), 
                'ngp': np.array([kwargs['ng1'], kwargs['ng2'], kwargs['ng3'], kwargs['ng4']])
            }
            if self.MODEL == 2:
                blockage_args['groundModel'] = Mirror()
        
        return All2AllIterative(
            self.site, self.turbine,
            wake_deficitModel=wake_deficitModel,
            superpositionModel=LinearSum(),
            deflectionModel=None,
            turbulenceModel=CrespoHernandez(**turb_args),
            blockage_deficitModel=SelfSimilarityDeficit2020(**blockage_args)
        )
    
    def evaluate_rmse(self, **kwargs):
        """Evaluate RMSE for given parameters"""
        try:
            wfm = self._create_wake_farm_model(**kwargs)
            sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                         wd=[270] * self.full_ti.size, time=True)
            
            # Build flow map
            flow_map = None
            for tt in range(self.full_ws.size):
                fm = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y), 
                                    time=[tt])['WS_eff']
                if flow_map is None:
                    flow_map = fm
                else:
                    flow_map = xr.concat([flow_map, fm], dim='time')
            
            # Calculate deficits (note: flow_map.WS_eff is velocity, we need deficit)
            pred = (sim_res.WS - flow_map.isel(h=0)) / sim_res.WS
            
            rmse = float(np.sqrt(((self.all_obs - pred) ** 2).mean(['x', 'y'])).mean('time'))
            
            if np.isnan(rmse):
                return -0.5
            return -rmse
        
        except Exception as e:
            print(f"Error in evaluation: {e}")
            return -0.5
    
    def optimize(self, init_points=50, n_iter=200):
        """Run Bayesian optimization"""
        self.optimizer = BayesianOptimization(
            f=self.evaluate_rmse, 
            pbounds=self.pbounds, 
            random_state=1
        )
        
        self.optimizer.probe(params=self.defaults, lazy=True)
        self.optimizer.maximize(init_points=init_points, n_iter=n_iter)
        
        self.best_params = self.optimizer.max['params']
        self.best_rmse = -self.optimizer.max['target']
        
        return self.best_params, self.best_rmse
    
    def create_optimization_animation(self, filename=None):
        """Create optimization convergence animation"""
        if filename is None:
            filename = f'optimization_animation_{self.X_LB}_{self.X_UB}.mp4'
        
        def update_plot(frame):
            ax1.clear()
            ax2.clear()
            
            # Get best so far
            best_so_far_params = {}
            best_so_far_rmse = float('inf')
            best_so_far_rmses = []
            
            for i in range(frame + 1):
                if -self.optimizer.space.target[i] <= best_so_far_rmse:
                    best_so_far_rmse = -self.optimizer.space.target[i]
                    best_so_far_params = self.optimizer.res[i]['params']
                best_so_far_rmses.append(best_so_far_rmse)
            
            # Plot convergence
            ax1.plot(-np.array(self.optimizer.space.target), color='gray', alpha=0.5)
            ax1.plot(np.array(best_so_far_rmses), color='black')
            ax1.set_title('Optimization Convergence')
            ax1.set_xlabel('Iteration')
            ax1.set_ylabel('RMSE')
            ax1.grid(True)
            
            # Plot parameters
            keys = list(best_so_far_params.keys())
            best_vals = [best_so_far_params[key] for key in keys]
            default_vals = [self.defaults[key] for key in keys]
            
            ax2.bar(keys, best_vals, label='Optimized')
            ax2.bar(keys, default_vals, edgecolor='black', linewidth=2, 
                   color='none', capstyle='butt', label='Default')
            ax2.set_title(f'Best RMSE: {best_so_far_rmse:.4f}')
            ax2.tick_params(axis='x', rotation=45)
            ax2.legend()
            plt.tight_layout()
            
            return ax1, ax2
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        ani = animation.FuncAnimation(fig, update_plot, 
                                    frames=len(self.optimizer.space.target), 
                                    repeat=False)
        
        writer = animation.FFMpegWriter(fps=15)
        ani.save(filename, writer=writer)
        plt.close('all')
    
    def evaluate_final_performance(self, save_plots=True):
        """Evaluate final model performance with detailed plots"""
        wfm = self._create_wake_farm_model(**self.best_params)
        sim_res = wfm([0], [0], ws=self.full_ws, TI=self.full_ti, 
                     wd=[270] * self.full_ti.size, time=True)
        
        rmse_values = []
        error_fields = []
        
        for t in range(sim_res.time.size):
            this_pred_sim = sim_res.isel(time=t)
            observed_deficit = self.flow_roi.deficits.interp(
                ct=this_pred_sim.CT, ti=this_pred_sim.TI, z=0
            ).isel(wt=0)
            
            flow_map_t = sim_res.flow_map(HorizontalGrid(x=self.target_x, y=self.target_y), 
                                        time=[t])
            pred = (this_pred_sim.WS - flow_map_t.WS_eff.isel(h=0, time=0)) / this_pred_sim.WS
            
            diff = observed_deficit.T - pred
            error_fields.append(diff)
            rmse = np.sqrt(np.mean(diff**2))
            rmse_values.append(rmse)
            
            if save_plots:
                fig, ax = plt.subplots(3, 1, figsize=(5, 15))
                
                co = ax[0].contourf(self.target_x, self.target_y, observed_deficit.T)
                cp = ax[1].contourf(self.target_x, self.target_y, pred)
                cd = ax[2].contourf(self.target_x, self.target_y, diff)
                
                for jj, c in enumerate([co, cp, cd]):
                    fig.colorbar(c, ax=ax[jj])
                
                ax[0].set_title('Observed Deficit')
                ax[1].set_title('Predicted Deficit')
                ax[2].set_title('Error')
                
                plt.tight_layout()
                plt.savefig(f'figs/downstream_err_{t}.png')
                plt.close()
        
        # Calculate summary statistics
        all_errors = xr.concat(error_fields, dim='time')
        avg_error = float(all_errors.mean())
        p90_error = float(all_errors.quantile(0.9))
        overall_rmse = np.mean(rmse_values)
        
        print(f"Average Error: {avg_error:.4f}")
        print(f"P90 Error: {p90_error:.4f}")
        print(f"Overall RMSE: {overall_rmse:.4f}")
        print(f"RMSE per time step: {rmse_values}")
        
        return {
            'rmse_values': rmse_values,
            'overall_rmse': overall_rmse,
            'avg_error': avg_error,
            'p90_error': p90_error,
            'error_fields': all_errors
        }
    
    def plot_parameter_comparison(self):
        """Plot optimized vs default parameters"""
        keys = list(self.best_params.keys())
        best_vals = [self.best_params[key] for key in keys]
        default_vals = [self.defaults[key] for key in keys]
        
        plt.figure(figsize=(12, 6))
        plt.bar(keys, best_vals, label='Optimized')
        plt.bar(keys, default_vals, edgecolor='black', linewidth=2, 
               color='none', capstyle='butt', label='Default')
        plt.title(f'Optimal RMSE: {self.best_rmse:.4f}')
        plt.xticks(rotation=45)
        plt.legend()
        plt.tight_layout()
        plt.savefig(f'bar_LB_{self.X_LB}_UP_{self.X_UB}.png')
        plt.show()

# Usage example:
if __name__ == "__main__":
    # Configuration
    MODEL = 2  # 1 or 2
    UPSTREAM = False  # True for upstream (blockage), False for downstream (wake)
    
    # Create optimizer
    optimizer = WakeModelOptimizer(model=MODEL, upstream=UPSTREAM)
    
    # Run optimization
    best_params, best_rmse = optimizer.optimize(init_points=50, n_iter=200)
    
    # Create animation
    optimizer.create_optimization_animation()
    
    # Evaluate performance
    performance = optimizer.evaluate_final_performance()
    
    # Plot parameter comparison
    optimizer.plot_parameter_comparison()
    
    print(f"Best parameters: {best_params}")
    print(f"Best RMSE: {best_rmse:.4f}")
```

Key improvements in this rewrite:

1. **Modular Design**: Everything is now encapsulated in a `WakeModelOptimizer` class
2. **Clear Separation**: Different setup phases are in separate methods
3. **Better Error Handling**: Try-catch blocks for robustness
4. **Improved Flow Field Analysis**: Added average and P90 error reporting as you requested
5. **Cleaner Parameter Management**: Centralized parameter bounds and defaults
6. **Better Documentation**: Clear docstrings for each method
7. **Flexible Configuration**: Easy to switch between models and upstream/downstream modes

The main benefits:
- Much easier to maintain and modify
- Clear separation of concerns
- Better error handling
- More comprehensive performance evaluation with the statistics you wanted
- Reusable components

You can now easily instantiate different configurations and the code handles all the complexity of setting up the appropriate deficit models, turbulence models, and blockage models based on your MODEL and UPSTREAM settings.