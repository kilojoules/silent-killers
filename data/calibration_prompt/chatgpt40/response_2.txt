Your code is quite comprehensive and seems to be addressing a complex problem related to wind farm modeling using the `py_wake` library. Here's some feedback and suggestions for improvement, specifically focusing on modularization and clarity:

### General Structure

1. **Modularization**: You can break down the code into smaller functions or classes to improve readability and maintainability. For example:
   - A function to load and preprocess data.
   - A function to set up different models based on parameters.
   - A function to perform the simulation.
   - A function to calculate RMSE.
   - A function for plotting results.

2. **Configuration**: Consider using a configuration file or class to store parameters, such as model settings, bounds, and defaults. This can make it easier to manage and update settings without modifying the core logic.

3. **Error Handling**: Add error handling to manage potential issues, such as missing data or invalid parameter values, to make the code more robust.

### Specific Areas for Improvement

1. **Flow Field Plots**: If you're reporting average and p90s of the errors, ensure that your plots reflect these statistics clearly. You might want to create separate plots for these statistics or include them as annotations on existing plots.

2. **Velocity Deficits**: Since `flow_map.WS_eff` is the velocity, ensure that when you're comparing it to the reference data's velocity deficits, you're consistent in how you're calculating and interpreting these values.

3. **Code Comments**: More detailed comments explaining the purpose of each major block of code would be beneficial, especially for others who might read or maintain the code.

4. **Performance**: Depending on the dataset size and complexity of the models, performance may become an issue. Consider profiling your code to identify bottlenecks and optimize them, possibly using parallel processing or more efficient data structures.

5. **Testing**: Implement unit tests for your modular functions to ensure they work correctly. This will help in maintaining the code over time.

6. **Visualization**: Ensure that your plots are clear and informative. Labels, legends, and titles should be present and descriptive. You might also consider using interactive plots if the data exploration would benefit from it.

### Example of Modularization

Here's a simple example of how you might start breaking down the code into functions:

```python
def load_data(file_path, D):
    dat = xr.load_dataset(file_path)
    turbine = DTU10MW()
    dat = dat.assign_coords(x=dat.x * D, y=dat.y * D)
    return dat, turbine

def setup_wake_model(site, turbine, model_params, downwind=True, model_type=2):
    if downwind:
        # Setup for downwind models
        # Use model_type to switch between different models
        pass
    else:
        # Setup for other scenarios
        pass
    # Return the configured model
    return All2AllIterative(...)

def calculate_rmse(sim_res, all_obs, flow_map):
    # Calculate and return RMSE
    pass

def run_optimization(evaluate_rmse, pbounds, defaults):
    optimizer = BayesianOptimization(f=evaluate_rmse, pbounds=pbounds, random_state=1)
    optimizer.probe(params=defaults, lazy=True)
    optimizer.maximize(init_points=50, n_iter=200)
    return optimizer

# Main execution
if __name__ == '__main__':
    # Load data
    dat, turbine = load_data('./DTU10MW.nc', D)

    # Setup model
    wfm = setup_wake_model(...)

    # Run simulation and calculate RMSE
    sim_res = wfm(...)
    rmse = calculate_rmse(sim_res, all_obs, flow_map)

    # Run optimization
    optimizer = run_optimization(evaluate_rmse, pbounds, defaults)

    # Plot results
    plot_results()
```

By structuring your code in this way, you create a more organized and maintainable codebase. This makes it easier to understand, debug, and extend in the future.