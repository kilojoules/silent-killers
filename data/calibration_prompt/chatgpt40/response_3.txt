Your code is quite comprehensive and does a lot of things, from data loading and processing to optimization and visualization. However, there are several areas where you can improve modularity, readability, and potentially performance. Here's a structured approach to refactor and improve your code:

### 1. Modularization

**Separate Concerns:**
- **Data Handling:** Functions for data loading and preparation.
- **Model Configuration:** Functions to set up and configure models based on parameters.
- **Evaluation and Optimization:** Functions for RMSE evaluation and Bayesian Optimization.
- **Visualization:** Functions for plotting and animations.

### 2. Code Refactoring

Here's a proposal for a more modular structure. This is a high-level suggestion, and you'll need to adapt it to your specific needs.

#### Data Handling

```python
def load_and_prepare_data(file_path, turbine):
    dat = xr.load_dataset(file_path)
    D = turbine.diameter()
    dat = dat.assign_coords(x=dat.x * D, y=dat.y * D)
    return dat, D

def select_region_of_interest(dat, D, downwind):
    if downwind:
        roi_x = slice(2 * D, 10 * D)
    else:
        roi_x = slice(-2 * D, -1 * D)
    roi_y = slice(-2 * D, 2 * D)
    return dat.sel(x=roi_x, y=roi_y)
```

#### Model Configuration

```python
def configure_models(downwind, model, kwargs):
    if downwind:
        if model == 1:
            wake_deficit_model = BlondelSuperGaussianDeficit2020(**kwargs)
            blockage_args = {}
        else:
            wake_deficit_model = TurboGaussianDeficit(**kwargs)
            blockage_args = {}
    else:
        wake_deficit_model = BlondelSuperGaussianDeficit2020()
        blockage_args = kwargs
    return wake_deficit_model, blockage_args
```

#### Evaluation and Optimization

```python
def evaluate_rmse(wfm, all_obs, full_ws, full_ti, target_x, target_y):
    # Similar logic as before
    return -rmse  # Ensure this is negative to minimize

def optimize_parameters(pbounds, defaults):
    optimizer = BayesianOptimization(f=evaluate_rmse, pbounds=pbounds, random_state=1)
    optimizer.probe(params=defaults, lazy=True)
    optimizer.maximize(init_points=50, n_iter=200)
    return optimizer
```

#### Visualization

```python
def plot_results(optimizer, defaults, keys):
    # Plotting logic
```

### 3. Error Reporting and Visualization

**Flow Field Plots:**
- Consider using more informative color maps and labels.
- Show both average and P90 errors in plots for diagnostic purposes.

### 4. Improving Readability

- **Naming Conventions:** Use descriptive variable names.
- **Comments and Docstrings:** Add comments and function docstrings to explain logic.
- **Consistent Formatting:** Ensure consistent use of spaces and indentation.

### 5. Performance Considerations

- **Vectorization:** Ensure operations are vectorized where possible.
- **Efficient Data Structures:** Use appropriate data structures for computational efficiency.

By breaking down your code into smaller, self-contained functions, you not only improve readability and maintainability but also make it easier to debug and test individual components. This approach will also facilitate collaboration with others and adaptation to future changes or new requirements.