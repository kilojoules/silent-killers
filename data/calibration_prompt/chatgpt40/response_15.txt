Your code and approach seem quite comprehensive for optimizing wind farm models using Bayesian Optimization. Let me provide some feedback and suggestions for potential improvements:

### Flow Field Plots
1. **Error Visualization**: You mentioned needing to change the flow field plots to report average and p90s of the errors. Itâ€™s a good idea to include statistical summaries like average, P90, and potentially standard deviation to better understand the distribution of errors. This can provide insights into the variability and reliability of your model predictions.

2. **Plot Enhancements**: Consider using additional visualization techniques such as heatmaps or 3D surface plots if applicable. They can offer more intuitive insights into how errors are distributed spatially across your wind farm.

### Code Modularity
1. **Modularization**: Your code could benefit from further modularization, especially in terms of setting up the wind farm model (`wfm`) and handling different configurations (`MODEL` and `DOWNWIND`). Consider creating functions or classes that encapsulate these setups, making it easier to change configurations or add new models in the future.

2. **Parameter Handling**: You could refactor the parameter handling by creating a dictionary or a data structure that manages model parameters based on the `MODEL` and `DOWNWIND` flags. This can reduce repetitive code and make it easier to extend or modify parameter sets.

### Code Suggestions
1. **Function for Wake Model Setup**: Create a function to set up the wake model based on model parameters. This can help avoid code repetition and make it easier to test different configurations.
   ```python
   def setup_wake_model(model, downwind, params):
       if downwind:
           if model == 1:
               wake_deficitModel = BlondelSuperGaussianDeficit2020(**params['deficit'])
               turbulenceModel = CrespoHernandez(**params['turbulence'])
               blockage_deficitModel = None
           else:
               wake_deficitModel = TurboGaussianDeficit(**params['deficit'])
               turbulenceModel = CrespoHernandez(**params['turbulence'])
               blockage_deficitModel = None
       else:
           wake_deficitModel = BlondelSuperGaussianDeficit2020()
           turbulenceModel = None
           blockage_deficitModel = SelfSimilarityDeficit2020(**params['blockage'])
       return wake_deficitModel, turbulenceModel, blockage_deficitModel
   ```

2. **Flow Map Prediction**: Consider separating the flow map prediction logic into its own function. This can help you focus on optimizing this part of the code without dealing with the entire workflow.
   ```python
   def predict_flow_map(sim_res, target_x, target_y, times):
       flow_map = None
       for t in times:
           fm = sim_res.flow_map(HorizontalGrid(x=target_x, y=target_y), time=[t])['WS_eff']
           flow_map = fm if flow_map is None else xr.concat([flow_map, fm], dim='time')
       return flow_map
   ```

3. **Error Evaluation**: Similarly, you can modularize the RMSE calculation and other error metrics.
   ```python
   def calculate_rmse(observed, predicted):
       rmse = float(np.sqrt(((observed - predicted) ** 2).mean(['x', 'y'])).mean('time'))
       return rmse if not np.isnan(rmse) else -0.5
   ```

### General Recommendations
- **Documentation**: Ensure that your code is well-documented, especially where complex logic or domain-specific knowledge is involved. This will help others (or future you) understand the code more easily.
- **Testing**: Consider adding unit tests for your functions, especially those responsible for setting up models and calculating metrics. This ensures that any changes or refactorings do not introduce errors.
- **Performance**: If performance becomes an issue, look into optimizing your data handling and calculations, possibly leveraging parallel processing if applicable.

Overall, your setup is quite advanced and well thought out. By modularizing the code further and focusing on enhancing the flow field plots, you can improve both its maintainability and the insights it provides.