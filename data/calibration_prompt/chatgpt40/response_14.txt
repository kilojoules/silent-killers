Your code seems to be a complex simulation and optimization task using wind farm models, with a focus on minimizing root mean square error (RMSE) through Bayesian optimization. Here are some thoughts on your approach, along with suggestions for improvements:

### Observations

1. **Flow Field Plots**:
   - If the current flow field plots are not effectively communicating the results, consider using different visualization techniques. For instance, you could explore interactive plots or 3D visualizations to better capture the nuances of the flow fields.

2. **Error Reporting**:
   - Reporting both the average and P90 (90th percentile) of the errors makes sense, as it gives a more comprehensive picture of model performance. While the average provides a general view, the P90 can highlight worst-case scenarios.

3. **Modular Code Structure**:
   - Your code could benefit from increased modularization. Breaking it down into smaller, more manageable functions or classes can make it easier to understand, maintain, and extend.

### Suggestions for Improvements

1. **Refactor for Modularization**:
   - **Instantiating the WFM**: Create a separate function to handle the instantiation of the wind farm model. This function can take parameters for the specific models and settings (deficit, turbulence, etc.) and return the configured model.
   - **Parameter Handling**: Encapsulate parameter definitions and the logic that switches between different parameter sets based on conditions (e.g., `DOWNWIND` and `MODEL`) into functions or classes.
   - **Visualization**: Create a dedicated function for generating plots. This can reduce redundancy and improve readability.

2. **Error Metric Functions**:
   - Create separate methods for calculating RMSE, P90, and other metrics you’re interested in. This will make it easier to change or add new metrics in the future.

3. **Use of Configurations**:
   - Consider using a configuration file (e.g., JSON, YAML) to store settings and parameter bounds. This can make your script more flexible and easier to adapt to different scenarios.

4. **Improve Comments and Documentation**:
   - Ensure that each function and complex logic block has descriptive comments explaining what the code is doing. This will help anyone who reads the code in the future, including yourself.

5. **Performance Optimization**:
   - Depending on the size of your datasets and the complexity of your simulations, performance optimization might be necessary. Consider profiling your code to identify bottlenecks and explore options like parallel processing or optimized libraries.

6. **Testing**:
   - If you haven’t already, consider adding tests to validate the functionality of your modularized components. This will ensure that changes or optimizations don’t break existing functionality.

Here's a basic example of how you might start to refactor part of your code into functions:

```python
def create_wind_farm_model(site, turbine, model_params, downwind=True):
    """
    Creates and returns a configured wind farm model based on the specified parameters.
    """
    if downwind:
        wake_deficit_model = BlondelSuperGaussianDeficit2020(**model_params['deficit'])
        turbulence_model = CrespoHernandez(**model_params['turbulence'])
        blockage_deficit_model = SelfSimilarityDeficit2020()
    else:
        # Define other configurations for non-downwind scenarios
        pass

    return All2AllIterative(
        site, turbine,
        wake_deficitModel=wake_deficit_model,
        superpositionModel=LinearSum(),
        deflectionModel=None,
        turbulenceModel=turbulence_model,
        blockage_deficitModel=blockage_deficit_model
    )

def plot_flow_fields(flow_map, observed_deficit, pred, target_x, target_y, time_step):
    """
    Generates and saves contour plots for observed, predicted, and difference fields.
    """
    fig, ax = plt.subplots(3, 1, figsize=(5, 15))
    co = ax[0].contourf(target_x, target_y, observed_deficit)
    cp = ax[1].contourf(target_x, target_y, pred)
    cd = ax[2].contourf(target_x, target_y, observed_deficit - pred)

    for jj, c in enumerate([co, cp, cd]):
        fig.colorbar(c, ax=ax[jj])

    ax[0].set_ylabel('Observed')
    ax[1].set_ylabel('Prediction')
    ax[2].set_ylabel('Diff')
    plt.tight_layout()
    plt.savefig(f'figs/downstream_err_{time_step}')
    plt.clf()
```

This is just a starting point, and you can expand on this by considering the other suggestions as you refactor your code.