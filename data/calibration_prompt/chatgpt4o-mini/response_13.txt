Your approach to the wind farm model (WFM) simulation and optimization using the PyWake library is quite comprehensive. However, it can definitely benefit from a more modular structure, improved error handling, and clearer plotting strategies, especially since you're interested in changing how you visualize flow fields and report errors.

### Key Suggestions for Improvement

1. **Modular Code Structure**:
   - Break down large functions into smaller, manageable ones. For instance, separate the logic for initializing the WFM, running simulations, and evaluating RMSE into distinct functions.
   - Use a configuration class or dictionary to encapsulate model parameters and options. This makes it easier to manage and modify settings.

2. **Error Reporting**:
   - Instead of just calculating RMSE, consider implementing functions to compute additional metrics like the average and 90th percentile (P90) of the errors.
   - You can create a function to return a summary of the error metrics for better insights into model performance.

3. **Flow Field Visualization**:
   - Implement a dedicated function to handle flow field visualization. This can take parameters for the type of plot (e.g., contour, quiver) and error metrics (e.g., RMSE, average, P90).
   - Use `matplotlib` functionality to customize the plots for clarity, such as adding titles, labels, and color maps.

4. **Parameter Handling**:
   - Consider using `dataclasses` for parameter management, which can improve readability and enforce structure.
   - Use default parameters and allow for overrides through function arguments to keep your API clean.

5. **Optimization Process**:
   - Ensure that the optimizer's state is easily retrievable and that you capture the best parameters and performance metrics clearly.
   - Consider logging or saving the optimization history for later analysis.

6. **Error Handling**:
   - Add error handling to manage exceptions that may arise during simulations, particularly when loading datasets or during model evaluations.

### Example Refactor

Here's a simplified version of how you might start modularizing some of the code:

```python
import numpy as np
import xarray as xr
from py_wake import HorizontalGrid
from py_wake.wind_farm_models import All2AllIterative
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from bayes_opt import BayesianOptimization

# Define a configuration class for parameters
class Config:
    def __init__(self, model, downwind):
        self.model = model
        self.downwind = downwind
        self.roi = self.set_roi()
        self.site = Hornsrev1Site()

    def set_roi(self):
        D = turbine.diameter()
        if self.downwind:
            return slice(2 * D, 10 * D), slice(-2 * D, 2 * D)
        return slice(-10 * D, -2 * D), slice(-2 * D, 2 * D)

def initialize_wfm(site, turbine, params):
    # Initialize the wind farm model with provided parameters
    return All2AllIterative(site, turbine,
                             wake_deficitModel=params['wake_deficitModel'],
                             superpositionModel=params['superpositionModel'],
                             turbulenceModel=params['turbulenceModel'])

def run_simulation(wfm, full_ws, full_ti):
    return wfm([0], [0], ws=full_ws, TI=full_ti, wd=[270] * len(full_ti), time=True)

def evaluate_rmse(sim_res, observed_data):
    # Calculate RMSE or other metrics
    pass  # Implement RMSE calculation logic

def plot_results():
    # Implement plotting logic
    pass

# Main execution flow
if __name__ == "__main__":
    # Load data, initialize configurations, etc.
    
    config = Config(MODEL, DOWNWIND)
    wfm = initialize_wfm(config.site, turbine, {
        'wake_deficitModel': ...,
        'superpositionModel': ...,
        'turbulenceModel': ...
    })

    sim_res = run_simulation(wfm, full_ws, full_ti)
    rmse = evaluate_rmse(sim_res, observed_data)
    plot_results()
```

### Conclusion

By modularizing your code and incorporating clearer error reporting and visualization strategies, you'll enhance the maintainability and readability of your project. This will also make it easier to adapt the code as your project evolves.