Your code appears to be a comprehensive implementation for simulating wind farm performance and optimizing wake models using Bayesian optimization. Here are a few thoughts and suggestions on your approach, particularly considering your desire to improve modularity and error reporting:

### General Impressions
1. **Modularization**: Your current code structure is quite linear and could benefit from modularization. Breaking down your code into smaller, reusable functions will enhance readability, maintainability, and testing. Functions could include:
   - **Data Loading**: A function to load datasets and handle preprocessing.
   - **Model Initialization**: A function to instantiate the wind farm model based on selected parameters.
   - **Simulation Execution**: A function to run simulations and collect results.
   - **Error Evaluation**: A function to compute RMSE and other statistics.

2. **Error Reporting**: You mentioned wanting to report average and p90 errors. This can be effectively integrated into your `evaluate_rmse` function. Consider returning a dictionary or a structured result that includes these metrics, which can be useful for analysis later.

3. **Flow Field Plots**: If you plan to visualize flow field plots more effectively, consider creating a separate function dedicated to plotting. This function can take in the observed and predicted values as parameters and handle the plotting logic.

### Suggested Code Rewrite
Here's a modularized version of your code that incorporates the above suggestions. Please note that this is a simplified version and may require adjustments based on your exact needs and data structure:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import xarray as xr
from py_wake import (
    HorizontalGrid,
    All2AllIterative,
    LinearSum,
    GaussianOverlapAvgModel,
    TurboGaussianDeficit,
    BlondelSuperGaussianDeficit2020,
    SelfSimilarityDeficit2020,
    CrespoHernandez,
    Mirror,
)
from py_wake.examples.data.dtu10mw._dtu10mw import DTU10MW
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from bayes_opt import BayesianOptimization
from py_wake.deficit_models.utils import ct2a_mom1d

# Load dataset and preprocess
def load_data(file_path):
    data = xr.load_dataset(file_path)
    turbine = DTU10MW()
    D = turbine.diameter()
    data = data.assign_coords(x=data.x * D, y=data.y * D)
    return data, turbine, D

# Initialize model based on parameters
def initialize_model(site, turbine, model, downwind, params):
    if downwind:
        if model == 1:
            def_args = {k: params[k] for k in ['a_s', 'b_s', 'c_s', 'b_f', 'c_f']}
            wake_deficit_model = BlondelSuperGaussianDeficit2020(**def_args)
        else:
            turb_args = {'c': np.array([params['ch1'], params['ch2'], params['ch3'], params['ch4']])}
            wake_deficit_model = TurboGaussianDeficit(
                A=params['A'],
                cTI=[params['cti1'], params['cti2']],
                ctlim=params['ctlim'],
                ceps=params['ceps'],
                ct2a=ct2a_mom1d,
                groundModel=Mirror(),
                rotorAvgModel=GaussianOverlapAvgModel(),
            )
            wake_deficit_model.WS_key = 'WS_jlk'
    else:
        # Add logic for non-downwind cases
        pass
    
    return All2AllIterative(site, turbine, wake_deficitModel=wake_deficit_model, 
                            superpositionModel=LinearSum(), deflectionModel=None,
                            turbulenceModel=CrespoHernandez(**turb_args), 
                            blockage_deficitModel=SelfSimilarityDeficit2020())

# Evaluate RMSE and other statistics
def evaluate_rmse(sim_res, all_obs, flow_map):
    pred = (sim_res.WS - flow_map.WS_eff.isel(h=0)) / sim_res.WS
    rmse = float(np.sqrt(((all_obs - pred) ** 2).mean(['x', 'y'])).mean('time'))
    
    # Calculate p90
    p90_error = np.percentile(np.abs(all_obs - pred), 90)
    
    if np.isnan(rmse): return -0.5
    return {'rmse': -rmse, 'p90': p90_error}

# Plotting function
def plot_results(results):
    # Implement your plotting logic here
    pass

# Main execution logic
def main():
    dat, turbine, D = load_data('./DTU10MW.nc')
    site = Hornsrev1Site()
    
    # Set parameters and flow region
    DOWNWIND = True
    MODEL = 2
    roi_x, roi_y = slice(2 * D, 10 * D), slice(-2 * D, 2 * D)
    flow_roi = dat.sel(x=roi_x, y=roi_y)

    # Execute simulations and optimize
    pbounds = {...}  # Define your parameter bounds
    optimizer = BayesianOptimization(f=lambda x: evaluate_rmse(...), pbounds=pbounds, random_state=1)
    
    # Optimize and evaluate results
    optimizer.maximize(init_points=50, n_iter=200)
    best_params = optimizer.max['params']
    
    # Initialize and run the model with best parameters
    wfm = initialize_model(site, turbine, MODEL, DOWNWIND, best_params)
    
    # Collect results and plot
    results = wfm(...)  # Pass necessary parameters
    plot_results(results)

if __name__ == "__main__":
    main()
```

### Final Notes
- **Error Handling**: Consider adding error handling to manage exceptions gracefully, especially during data loading and model execution.
- **Documentation**: Comment your functions and their parameters to improve code clarity for future users (or yourself).
- **Testing**: Implement unit tests for your functions to validate their performance and correctness.

This modular approach should make your code cleaner, easier to maintain, and adaptable to future changes or enhancements.