Your code appears to be a comprehensive implementation of a wind farm model using the PyWake library, where you are simulating wake effects and optimizing parameters using Bayesian optimization. Here are some thoughts on your approach and suggestions for modularizing the code while maintaining the relevant settings:

### Key Observations:
1. **Modularity**: The current implementation has a lot of logical blocks that could be modularized into functions. This would enhance readability and maintainability. For example, you could create functions for data loading, model instantiation, simulation, and evaluation.

2. **Flow Field Plots**: You mentioned considering improvements regarding flow field plots and error reporting (averages and P90s). This is a good idea as it would provide more insight into the performance of your model. You might want to use libraries like `seaborn` for better visualizations or `matplotlib`'s built-in functions to calculate and display averages and percentiles.

3. **Performance Metrics**: The RMSE is a solid metric, but depending on the application, you might also consider other metrics such as MAE (Mean Absolute Error) or RÂ² (coefficient of determination). Adding more metrics could provide a more comprehensive view of model performance.

4. **Error Handling**: Ensure that exceptions are handled gracefully. For example, checking for `NaN` values in your predictions should be accompanied by a logging mechanism or a fallback strategy.

5. **Code Organization**: The code could benefit from a more organized structure. Consider separating configuration, data processing, modeling, and evaluation into different modules or classes.

### Suggested Modularization:
Here is a basic structure of how you could refactor your code into functions:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import xarray as xr
from py_wake import HorizontalGrid
from py_wake.examples.data.dtu10mw._dtu10mw import DTU10MW
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from py_wake.deficit_models import BlondelSuperGaussianDeficit2020
from py_wake.wind_farm_models import All2AllIterative
from bayes_opt import BayesianOptimization

def load_data(file_path):
    return xr.load_dataset(file_path)

def configure_turbine():
    return DTU10MW()

def setup_roi(dat, D, downwind=True):
    if downwind:
        roi_x = slice(2 * D, 10 * D)
    else:
        roi_x = slice(-2 * D, -1 * D)
    roi_y = slice(-2 * D, 2 * D)
    return dat.sel(x=roi_x, y=roi_y)

def instantiate_models(site, turbine, model_type, downwind):
    # Set up the necessary models based on the specified parameters
    if model_type == 1:
        return BlondelSuperGaussianDeficit2020(), {}
    else:
        return TurboGaussianDeficit(), {}

def run_simulation(site, turbine, wake_model, full_ws, full_ti):
    wfm = All2AllIterative(site, turbine, wake_deficitModel=wake_model)
    sim_res = wfm([0], [0], ws=full_ws, TI=full_ti, wd=[270] * full_ti.size, time=True)
    return sim_res

def evaluate_rmse(obs_values, pred):
    return np.sqrt(np.mean((obs_values - pred) ** 2))

def plot_results(results):
    # Code to generate plots based on results
    pass

# Main execution flow
dat = load_data('./DTU10MW.nc')
turbine = configure_turbine()
D = turbine.diameter()
dat = dat.assign_coords(x=dat.x * D, y=dat.y * D)

site = Hornsrev1Site()
flow_roi = setup_roi(dat, D)

# Define parameters for optimization and simulations
# ...
# Include Bayesian optimization logic and parameter probing
# ...

# Run the simulations and evaluate the results
sim_res = run_simulation(site, turbine, wake_model, full_ws, full_ti)

# Evaluate RMSE and plot results
rmse = evaluate_rmse(all_obs, sim_res)
plot_results(rmse)
```

### Additional Considerations:
- **Documentation**: Add docstrings to your functions to clarify their purpose.
- **Testing**: Implement unit tests for your functions to ensure they work as expected.
- **Parameter Management**: Consider using a configuration file (like YAML or JSON) for model parameters instead of hardcoding them.

### Conclusion:
Your approach is solid, but modularizing the code will significantly enhance its maintainability and clarity. By structuring your code into functions or classes, you can simplify the logic and make it easier to implement changes or optimizations in the future.