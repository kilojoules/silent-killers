Your code for simulating wind farm performance and optimizing parameters looks quite comprehensive! Here are some thoughts on your approach and suggested improvements:

### General Observations:
1. **Modularization**: Your idea of rewriting the code to better modularize the instantiation of the wind farm model (WFM) is excellent. Modular code is easier to maintain, test, and reuse. Consider breaking down large functions into smaller ones that handle specific tasks (e.g., `initialize_wfm`, `run_simulation`, `evaluate_results`, etc.).

2. **Error Metrics**: Reporting both average and 90th percentile (P90) of the errors is a good strategy. It provides a more comprehensive view of the performance of your model, especially when dealing with outliers. Ensure you implement this in your evaluation section after getting the predictions.

3. **Use of Constants**: You have some hard-coded constants (like `270` for wind direction) throughout the code. Consider defining them at the top of your script or in a configuration section to make it easier to adjust parameters later.

4. **Efficiency**: The way you're running simulations within loops can be optimized. For instance, you might want to vectorize operations where possible, especially when handling large datasets.

5. **Documentation**: Adding comments and docstrings to functions would greatly enhance the readability and usability of your code, especially if others will be working with it.

### Specific Suggestions:
1. **Flow Field Plots**:
   - To change the flow field plots, you can calculate the average and P90 errors for each time step and then create visualizations based on those metrics. Use `numpy` functions like `np.mean()` and `np.percentile()` to help with this.

2. **Refactoring Code**: Hereâ€™s a rough outline of how you might refactor parts of your code:
   ```python
   def initialize_wfm(site, turbine, model_params, blockage_params):
       return All2AllIterative(
           site, turbine,
           wake_deficitModel=model_params['wake_deficit'],
           superpositionModel=LinearSum(),
           deflectionModel=None,
           turbulenceModel=CrespoHernandez(**model_params['turbulence']),
           blockage_deficitModel=SelfSimilarityDeficit2020(**blockage_params)
       )

   def run_simulation(wfm, ws, ti):
       return wfm([0], [0], ws=ws, TI=ti, wd=[270] * len(ti), time=True)

   def evaluate_predictions(sim_res, all_obs, target_x, target_y):
       # Your existing logic to evaluate predictions
   ```

3. **Error Calculation**:
   - You can create a function to calculate RMSE and include options for average and P90:
   ```python
   def calculate_rmse(predictions, observations):
       diff = observations - predictions
       rmse_avg = np.sqrt(np.mean(diff**2))
       rmse_p90 = np.percentile(np.abs(diff), 90)
       return rmse_avg, rmse_p90
   ```

4. **Visualization**:
   - For your plots, consider creating a function that handles the plotting to reduce redundancy. You can also use subplots to show multiple metrics in one figure.

5. **Parameter Optimization**:
   - Ensure that you have clear documentation about the optimization process. If you're using Bayesian Optimization, consider adding logging to track parameter changes and their effects on the RMSE.

### Example of a Modularized Version:
Below is a simplified example of how you might start to modularize the code:
```python
def main():
    # Load data and initialize parameters
    dat = load_data('./DTU10MW.nc')
    turbine = DTU10MW()
    site = Hornsrev1Site()

    # Define optimization parameters
    optimizer_params = define_optimizer_params()

    # Run optimization
    best_params = optimize_parameters(evaluate_rmse, optimizer_params)

    # Final simulation and evaluation
    wfm = initialize_wfm(site, turbine, best_params)
    sim_res = run_simulation(wfm, full_ws, full_ti)
    evaluate_predictions(sim_res, all_obs, target_x, target_y)

if __name__ == "__main__":
    main()
```

### Conclusion
Your approach is fundamentally solid, but restructuring the code for better modularity and clarity will improve maintainability and readability. Adding error metrics and refining the visualization process will provide you with valuable insights into your model's performance. Let me know if you want help with a specific part of the refactoring or any other suggestions!