Your code for simulating wind farm performance and optimizing wake models has a solid foundation, but it does seem to have some areas where you could improve modularity and readability. Here are some key points to consider about your current approach and suggestions for a potential rewrite:

### Current Approach Strengths
1. **Comprehensive Use of Libraries**: You're effectively leveraging libraries like `xarray`, `numpy`, and `py_wake`, which are well-suited for this type of analysis.
2. **Optimization Strategy**: Utilizing Bayesian optimization for parameter tuning is a smart choice, as it can efficiently explore the parameter space.
3. **Visualization**: Youâ€™ve included animations and contour plots to visualize the optimization process and performance metrics, which can be beneficial for diagnostics.

### Areas for Improvement
1. **Modularization**: The code is currently quite linear and could benefit from breaking down into functions or classes. This will improve readability, maintainability, and reusability of the code.
2. **Error Reporting**: You mentioned needing to report average and p90s of the errors. This could be incorporated into a separate function that computes these metrics.
3. **Parameter Management**: Consider creating a configuration class or dictionary to manage model parameters and defaults, making it easier to adjust settings in one place.
4. **Flow Field Plots**: As you noted, changing the flow field plots to report averages and p90s of errors would enhance your analysis and give a better insight into the model performance.

### Suggested Modular Rewrite
Here's an outline of how you could refactor the code:

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import xarray as xr
from py_wake import HorizontalGrid
from py_wake.examples.data.hornsrev1 import Hornsrev1Site
from py_wake.examples.data.dtu10mw._dtu10mw import DTU10MW
from bayes_opt import BayesianOptimization

class WindFarmModel:
    def __init__(self, site, turbine, model, downwind, params):
        self.site = site
        self.turbine = turbine
        self.model = model
        self.downwind = downwind
        self.params = params
        self.flow_map = None
        self.sim_res = None

    def setup_model(self):
        # Model setup logic based on the chosen parameters
        ...

    def run_simulation(self, ws, ti):
        # Run the wind farm simulation
        ...

    def evaluate_rmse(self, observed, predicted):
        # Calculate RMSE
        ...
    
    def visualize_results(self):
        # Visualization logic
        ...

def create_flow_roi(data, x_lb, x_ub, d):
    roi_x = slice(x_lb * d, x_ub * d)
    roi_y = slice(-2 * d, 2 * d)
    return data.sel(x=roi_x, y=roi_y)

def main():
    # Load data
    dat = xr.load_dataset('./DTU10MW.nc')
    turbine = DTU10MW()

    # Set parameters
    D = turbine.diameter()
    site = Hornsrev1Site()
    DOWNWIND = True
    MODEL = 2
    params = {}  # Define your parameter settings here

    # Create flow region of interest
    flow_roi = create_flow_roi(dat, 2, 10, D)

    # Instantiate and run the wind farm model
    wfm = WindFarmModel(site, turbine, MODEL, DOWNWIND, params)
    wfm.setup_model()
    wfm.run_simulation(ws, ti)  # Define ws and ti based on your requirements

    # Evaluating RMSEs and visualizing results
    wfm.evaluate_rmse()
    wfm.visualize_results()

if __name__ == "__main__":
    main()
```

### Key Changes in the Modular Approach
- **Class Structure**: The `WindFarmModel` class encapsulates all functionality related to the wind farm model, making it easier to manage.
- **Function Definitions**: Functions like `create_flow_roi` and `main` are clearly defined, allowing for better separation of concerns.
- **Parameter Management**: Parameters can be easily passed to the class or function, making the code more flexible.
  
### Conclusion
Refactoring your code into a more modular design will help you manage complexity as your project grows. It will also make it easier to test each component independently and adjust parameters as necessary. Integrating error reporting and visualization enhancements will further improve the usability and insight provided by your model.