To propagate measurement uncertainties through PyWake and visualize the Sobol sensitivity of effective wind speed (WS_eff) as a function of the spatial coordinates (x, y), we can create a Python script. This script will involve several key steps:

1. **Set up the environment**: Ensure you have the required dependencies installed.
2. **Define the inflow conditions with uncertainties**.
3. **Run the wake model simulations**.
4. **Calculate the Sobol sensitivity indices**.
5. **Generate flow field images**.
6. **Save the results**.

Below is a sample script that outlines this workflow:

```python
import numpy as np
import matplotlib.pyplot as plt
from pywake import PyWake
from SALib.sample import saltelli
from SALib.analyze import sobol
import os

# Step 1: Set up the environment
# Make sure to have PyWake, SALib, and other required libraries installed
# You can install them using pip if you haven't done so already.

# Step 2: Define the model parameters and uncertainties
# Define the problem for Sobol sensitivity analysis
problem = {
    'num_vars': 3,  # Number of input variables (e.g., wind speed, turbulence intensity, etc.)
    'names': ['wind_speed', 'turbulence_intensity', 'temperature'],  # Example parameters
    'bounds': [[5, 15], [0.1, 0.3], [10, 30]]  # Example ranges for these parameters
}

# Sample parameter sets using Saltelli's sampling method
param_values = saltelli.sample(problem, 1000)  # Generate 1000 samples

# Step 3: Run the wake model simulations
def run_pywake_simulation(wind_speed, turbulence_intensity, temperature):
    # Initialize the PyWake model with the given parameters
    # Assume you have a setup for your wind farm in PyWake
    # Example: farm = WindFarm(layout, wind_conditions)

    # Simulate the wake effects and get WS_eff
    # Replace with your actual model calls
    return np.random.uniform(5, 15, size=100)  # Placeholder for WS_eff output

# Collect results
WS_eff_results = []
for params in param_values:
    wind_speed, turbulence_intensity, temperature = params
    WS_eff = run_pywake_simulation(wind_speed, turbulence_intensity, temperature)
    WS_eff_results.append(WS_eff)

WS_eff_results = np.array(WS_eff_results)

# Step 4: Calculate the Sobol sensitivity indices
sobol_indices = sobol.analyze(problem, WS_eff_results, print_to_console=True)

# Step 5: Generate flow field images
def plot_flow_field(X, Y, Z, filename):
    plt.figure(figsize=(10, 6))
    plt.contourf(X, Y, Z, levels=30, cmap='viridis')
    plt.colorbar(label='WS_eff')
    plt.title('Flow Field of WS_eff')
    plt.xlabel('X Position [m]')
    plt.ylabel('Y Position [m]')
    plt.savefig(filename)
    plt.close()

# Create a grid for the flow field
x = np.linspace(0, 1000, 100)  # Example x-coordinates
y = np.linspace(0, 1000, 100)  # Example y-coordinates
X, Y = np.meshgrid(x, y)

# Iterate over Sobol indices to visualize sensitivity
for i, sensitivity in enumerate(sobol_indices['S1']):
    plot_flow_field(X, Y, sensitivity.reshape(X.shape), f'flow_field_sensitivity_{i}.png')

# Step 6: Save the results
if not os.path.exists('results'):
    os.makedirs('results')

np.save('results/WS_eff_results.npy', WS_eff_results)
np.save('results/sobol_indices.npy', sobol_indices)

print("Flow field images and results saved.")
```

### Notes:
1. **PyWake Initialization**: Replace the placeholder code in `run_pywake_simulation` with actual PyWake model initialization and simulation calls to compute `WS_eff`.
2. **Input Parameters**: Adjust the parameters and their ranges in the `problem` dictionary according to your specific use case.
3. **Output Saving**: Ensure the script's output directories exist or are created as needed.
4. **Flow Field Visualization**: The flow field visualization assumes a 2D grid of effective wind speeds. Adjust as necessary based on your model outputs.
5. **Installing Dependencies**: Make sure to install the required packages (PyWake, SALib, NumPy, Matplotlib) if you haven't already.

This script provides a basic framework to propagate uncertainties through a wind farm model and analyze the impact on wind speed measurements while visualizing the results. Adjustments may be necessary based on your specific requirements and model configurations.